<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="streaming audio, open source, low latency, directsound, wasapi, asio, alsa, jack, pulseaudio, .net, java, c#"/>
    <title>XT-Audio - An open source low-latency audio library</title>
    <link rel="stylesheet" type="text/css" href="css/github.css"/>
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
    <script type="text/javascript" src="js/jquery.min.js"></script>
    <script type="text/javascript" src="js/bootstrap.min.js"></script>
    <script type="text/javascript" src="js/highlight.pack.js"></script>
  </head>
  <body>
    <div id="container">
      <div class="lblock">
        <h1>XT-Audio</h1>
        <p/>
        Releases (<a href="https://github.com/sjoerdvankreel/xt-audio/blob/master/history.txt">changelog</a>):<br/>
        2.0.1: March 10, 2024: bugfix release<br/>
        2.0: December 24, 2021: bugfix release<br/>
        1.9: February 14, 2021: improve error handling<br/>
        1.8: January 21, 2021: nuget/mvn central support<br/>
        1.7: January 2, 2021: major cleanup/rewrite release<br/>
        1.0.6: July 8, 2020: .net core/java9 support<br/>
        1.0.5: February 14, 2018: bugfix release<br/>
      </div>
      <div class="rblock topblock">
        <h2>Streaming audio focused on low latency, platform independence and API simplicity.</h2>
        <p/>
        Binaries: <a href="dist/xt-audio-2.0.1.zip">Download latest</a><br/>
        Previous releases: <a href="dist">Browse</a><br/>
        Screenshot: <a href="img/gui.png">WASAPI example</a><br/>
        Get the source: <a href="https://github.com/sjoerdvankreel/xt-audio">XT-Audio on GitHub</a><br/>
      </div>
      <p style="clear: both;"></p>

      <div class="lblock">
        <h2>Features</h2>
        &bull; Aggregation: combine multiple devices into a single stream<br/>
        &bull; DirectSound, WASAPI, ASIO, Pulse, ALSA and JACK backends<br/>
        &bull; Channel masks, timestamps, full-duplex, (non)interleaved mode<br/>
        &bull; x86/x64 Windows/Linux (C/C++), JVM, .NET Framework/Core, Mono<br/><br/>
      </div>
      <div class="rblock">
      <h2>Docs</h2>
        <a href="doc/core/html/index.html">Core</a> /
        <a href="doc/cpp/html/index.html">C++</a> /
        <a href="doc/java/apidocs/index.html">Java</a> /
        <a href="doc/net/index.html">.NET</a><br/>
        Only the core (C) API is fully documented. Code samples are provided for all languages except C. Refer to the
        core documentation's main page for differences between the C API and other language APIs.
      </div>
      <p style="clear: both;"></p>

      <ul id="tabs" class="nav nav-tabs">
        <li class="active"><a href="#simple-list" data-toggle="tab" onclick="$('.tab-pane[id=simple-list] .nav-tabs a:first').tab('show');">Device list</a></li>
        <li><a href="#detailed-list" data-toggle="tab" onclick="$('.tab-pane[id=detailed-list] .nav-tabs a:first').tab('show');">Detailed list</a></li>
        <li><a href="#simple-playback" data-toggle="tab" onclick="$('.tab-pane[id=simple-playback] .nav-tabs a:first').tab('show');">Playback</a></li>
        <li><a href="#simple-record" data-toggle="tab" onclick="$('.tab-pane[id=simple-record] .nav-tabs a:first').tab('show');">Record</a></li>
        <li><a href="#advanced-playback" data-toggle="tab" onclick="$('.tab-pane[id=advanced-playback] .nav-tabs a:first').tab('show');">Advanced playback</a></li>
        <li><a href="#advanced-record" data-toggle="tab" onclick="$('.tab-pane[id=advanced-record] .nav-tabs a:first').tab('show');">Advanced record</a></li>
        <li><a href="#full-duplex" data-toggle="tab" onclick="$('.tab-pane[id=full-duplex] .nav-tabs a:first').tab('show');">Full duplex</a></li>
        <li><a href="#aggregate" data-toggle="tab" onclick="$('.tab-pane[id=aggregate] .nav-tabs a:first').tab('show');">Aggregation</a></li>
      </ul>
      <div class="tab-content">
        <div class="tab-pane active" id="simple-list">
          <ul class="nav nav-tabs">
            <li class="active"><a href="#simple-list-java" data-toggle="tab">Java</a></li>
            <li><a href="#simple-list-net" data-toggle="tab">.NET</a></li>
            <li><a href="#simple-list-cpp" data-toggle="tab">C++</a></li>
          </ul>
          <div class="usage">
            <br/>
            &bull; Print device names to stdout.
          </div>
          <div class="tab-content">
            <div class="tab-pane active" id="simple-list-java">
              <pre><code class="lang-java">package xt.sample;

import java.util.EnumSet;
import xt.audio.Enums.XtEnumFlags;
import xt.audio.Enums.XtSystem;
import xt.audio.XtAudio;
import xt.audio.XtDeviceList;
import xt.audio.XtPlatform;
import xt.audio.XtService;

public class PrintSimple {

    public static void main() throws Exception {
        try(XtPlatform platform = XtAudio.init(null, null)) {
            for(XtSystem system: platform.getSystems()) {
                XtService service = platform.getService(system);
                try(XtDeviceList list = service.openDeviceList(EnumSet.of(XtEnumFlags.ALL))) {
                    for(int d = 0; d &lt; list.getCount(); d++) {
                        String id = list.getId(d);
                        System.out.println(system + &quot;: &quot; + list.getName(id));
                    }
                }
            }
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="simple-list-net">
              <pre><code class="lang-cs">using System;

namespace Xt
{
    public static class PrintSimple
    {
        [STAThread]
        public static void Main()
        {
            using XtPlatform platform = XtAudio.Init(null, IntPtr.Zero);
            foreach (XtSystem system in platform.GetSystems())
            {
                XtService service = platform.GetService(system);
                using XtDeviceList list = service.OpenDeviceList(XtEnumFlags.All);
                for (int d = 0; d &lt; list.GetCount(); d++)
                {
                    string id = list.GetId(d);
                    Console.WriteLine(system + &quot;: &quot; + list.GetName(id));
                }
            }
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="simple-list-cpp">
              <pre><code class="lang-cpp">#include &lt;xt/XtAudio.hpp&gt;

#include &lt;memory&gt;
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int 
PrintSimpleMain() 
{
  std::unique_ptr&lt;Xt::Platform&gt; platform = Xt::Audio::Init(&quot;&quot;, nullptr);
  for(Xt::System system: platform-&gt;GetSystems()) 
  {
    std::unique_ptr&lt;Xt::Service&gt; service = platform-&gt;GetService(system);
    std::unique_ptr&lt;Xt::DeviceList&gt; list = service-&gt;OpenDeviceList(Xt::EnumFlagsAll);
    for(int32_t d = 0; d &lt; list-&gt;GetCount(); d++)
    {
      std::string id = list-&gt;GetId(d);
      std::cout &lt;&lt; system &lt;&lt; &quot;: &quot; &lt;&lt; list-&gt;GetName(id) &lt;&lt; &quot;\n&quot;;
    }
  }
  return 0;
}</code></pre>
            </div>
          </div>
        </div>
        <div class="tab-pane" id="detailed-list">
          <ul class="nav nav-tabs">
            <li><a href="#detailed-list-java" data-toggle="tab">Java</a></li>
            <li><a href="#detailed-list-net" data-toggle="tab">.NET</a></li>
            <li><a href="#detailed-list-cpp" data-toggle="tab">C++</a></li>
          </ul>
          <div class="usage">
            <br/>
            &bull; Initialize with application name and error logging callback.<br/>
            &bull; Query audio setups, service capabilities and default devices.<br/>
            &bull; Query device capabilities, mix, maximum channels and (non)interleaved access support.
          </div>
           <div class="tab-content">
            <div class="tab-pane" id="detailed-list-java">
              <pre><code class="lang-java">package xt.sample;

import java.util.EnumSet;
import xt.audio.Enums.XtEnumFlags;
import xt.audio.Enums.XtSetup;
import xt.audio.Enums.XtSystem;
import xt.audio.Structs.XtMix;
import xt.audio.Structs.XtVersion;
import xt.audio.XtAudio;
import xt.audio.XtDevice;
import xt.audio.XtDeviceList;
import xt.audio.XtException;
import xt.audio.XtPlatform;
import xt.audio.XtService;
import java.util.Optional;

public class PrintDetailed {

    static void onError(String message) {
        System.out.println(message);
    }

    static void printDevices(XtService service, XtDeviceList list) {
        for(int d = 0; d &lt; list.getCount(); d++) {
            String id = list.getId(d);
            try(XtDevice device = service.openDevice(id)) {
                Optional&lt;XtMix&gt; mix = device.getMix();
                System.out.println(&quot;    Device &quot; + id + &quot;:&quot;);
                System.out.println(&quot;      Name: &quot; + list.getName(id));
                System.out.println(&quot;      Capabilities: &quot; + list.getCapabilities(id));
                System.out.println(&quot;      Input channels: &quot; + device.getChannelCount(false));
                System.out.println(&quot;      Output channels: &quot; + device.getChannelCount(true));
                System.out.println(&quot;      Interleaved access: &quot; + device.supportsAccess(true));
                System.out.println(&quot;      Non-interleaved access: &quot; + device.supportsAccess(false));
                if(mix.isPresent())
                    System.out.println(&quot;      Current mix: &quot; + mix.get().rate + &quot; &quot; + mix.get().sample);
            } catch(Throwable t) {
                t.printStackTrace();
            }
        }
    }

    public static void main() throws Exception {
        XtAudio.setOnError(PrintDetailed::onError);
        try(XtPlatform platform = XtAudio.init(&quot;Sample&quot;, null)) {
            XtVersion version = XtAudio.getVersion();
            System.out.println(&quot;Version: &quot; + version.major + &quot;.&quot; + version.minor);
            XtSystem pro = platform.setupToSystem(XtSetup.PRO_AUDIO);
            System.out.println(&quot;Pro Audio: &quot; + pro + &quot; (&quot; + (platform.getService(pro) != null) + &quot;)&quot;);
            XtSystem system = platform.setupToSystem(XtSetup.SYSTEM_AUDIO);
            System.out.println(&quot;System Audio: &quot; + system + &quot; (&quot; + (platform.getService(system) != null) + &quot;)&quot;);
            XtSystem consumer = platform.setupToSystem(XtSetup.CONSUMER_AUDIO);
            System.out.println(&quot;Consumer Audio: &quot; + consumer + &quot; (&quot; + (platform.getService(consumer) != null) + &quot;)&quot;);

            for(XtSystem s: platform.getSystems()) {
                XtService service = platform.getService(s);
                System.out.println(&quot;System &quot; + s + &quot;:&quot;);
                System.out.println(&quot;  Capabilities: &quot; + service.getCapabilities());
                try(XtDeviceList all = service.openDeviceList(EnumSet.of(XtEnumFlags.ALL))) {
                    String defaultInputId = service.getDefaultDeviceId(false);
                    if(defaultInputId != null) {
                        String name = all.getName(defaultInputId);
                        System.out.println(&quot;  Default input: &quot; + name + &quot; (&quot; + defaultInputId + &quot;)&quot;);
                    }
                    String defaultOutputId = service.getDefaultDeviceId(true);
                    if(defaultOutputId != null) {
                        String name = all.getName(defaultOutputId);
                        System.out.println(&quot;  Default output: &quot; + name + &quot; (&quot; + defaultOutputId + &quot;)&quot;);
                    }
                }
                try(XtDeviceList inputs = service.openDeviceList(EnumSet.of(XtEnumFlags.INPUT))) {
                    System.out.println(&quot;  Input device count: &quot; + inputs.getCount());
                    printDevices(service, inputs);
                }
                try(XtDeviceList outputs = service.openDeviceList(EnumSet.of(XtEnumFlags.OUTPUT))) {
                    System.out.println(&quot;  Output device count: &quot; + outputs.getCount());
                    printDevices(service, outputs);
                }
            }
        } catch(Throwable t) {
            t.printStackTrace();
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="detailed-list-net">
              <pre><code class="lang-cs">using System;

namespace Xt
{
    public static class PrintDetailed
    {
        static void OnError(string message)
        =&gt; Console.WriteLine(message);

        static void PrintDevices(XtService service, XtDeviceList list)
        {
            for (int d = 0; d &lt; list.GetCount(); d++)
            {
                string id = list.GetId(d);
                try
                {
                    using XtDevice device = service.OpenDevice(id);
                    XtMix? mix = device.GetMix();
                    Console.WriteLine(&quot;    Device &quot; + id + &quot;:&quot;);
                    Console.WriteLine(&quot;      Name: &quot; + list.GetName(id));
                    Console.WriteLine(&quot;      Capabilities: &quot; + list.GetCapabilities(id));
                    Console.WriteLine(&quot;      Input channels: &quot; + device.GetChannelCount(false));
                    Console.WriteLine(&quot;      Output channels: &quot; + device.GetChannelCount(true));
                    Console.WriteLine(&quot;      Interleaved access: &quot; + device.SupportsAccess(true));
                    Console.WriteLine(&quot;      Non-interleaved access: &quot; + device.SupportsAccess(false));
                    if (mix != null) Console.WriteLine(&quot;      Current mix: &quot; + mix.Value.rate + &quot; &quot; + mix.Value.sample);
                } catch (Exception e)
                { Console.WriteLine(e); }
            }
        }

        [STAThread]
        public static void Main()
        {
            XtAudio.SetOnError(OnError);
            using XtPlatform platform = XtAudio.Init(&quot;Sample&quot;, IntPtr.Zero);
            try
            {
                XtVersion version = XtAudio.GetVersion();
                Console.WriteLine(&quot;Version: &quot; + version.major + &quot;.&quot; + version.minor);
                XtSystem pro = platform.SetupToSystem(XtSetup.ProAudio);
                Console.WriteLine(&quot;Pro Audio: &quot; + pro + &quot; (&quot; + (platform.GetService(pro) != null) + &quot;)&quot;);
                XtSystem system = platform.SetupToSystem(XtSetup.SystemAudio);
                Console.WriteLine(&quot;System Audio: &quot; + system + &quot; (&quot; + (platform.GetService(system) != null) + &quot;)&quot;);
                XtSystem consumer = platform.SetupToSystem(XtSetup.ConsumerAudio);
                Console.WriteLine(&quot;Consumer Audio: &quot; + consumer + &quot; (&quot; + (platform.GetService(consumer) != null) + &quot;)&quot;);

                foreach (XtSystem s in platform.GetSystems())
                {
                    XtService service = platform.GetService(s);
                    using XtDeviceList all = service.OpenDeviceList(XtEnumFlags.All);
                    Console.WriteLine(&quot;System: &quot; + s);
                    Console.WriteLine(&quot;  Capabilities: &quot; + service.GetCapabilities());
                    string defaultInput = service.GetDefaultDeviceId(false);
                    if (defaultInput != null)
                    {
                        string name = all.GetName(defaultInput);
                        Console.WriteLine(&quot;  Default input: &quot; + name + &quot; (&quot; + defaultInput + &quot;)&quot;);
                    }
                    string defaultOutput = service.GetDefaultDeviceId(true);
                    if (defaultOutput != null)
                    {
                        string name = all.GetName(defaultOutput);
                        Console.WriteLine(&quot;  Default output: &quot; + name + &quot; (&quot; + defaultOutput + &quot;)&quot;);
                    }
                    using XtDeviceList inputs = service.OpenDeviceList(XtEnumFlags.Input);
                    Console.WriteLine(&quot;  Input device count: &quot; + inputs.GetCount());
                    PrintDevices(service, inputs);
                    using XtDeviceList outputs = service.OpenDeviceList(XtEnumFlags.Output);
                    Console.WriteLine(&quot;  Output device count: &quot; + outputs.GetCount());
                    PrintDevices(service, outputs);
                }
            } catch (Exception e)
            { Console.WriteLine(e); }
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="detailed-list-cpp">
              <pre><code class="lang-cpp">#include &lt;xt/XtAudio.hpp&gt;

#include &lt;memory&gt;
#include &lt;cstdint&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

static void 
OnError(std::string const&amp; message)
{ std::cout &lt;&lt; message &lt;&lt; std::endl; }

void
PrintDevices(Xt::Service const* service, Xt::DeviceList const* list)
{
  for(int32_t d = 0; d &lt; list-&gt;GetCount(); d++)
  {
    std::string id = list-&gt;GetId(d);
    try
    {
      std::unique_ptr&lt;Xt::Device&gt; device = service-&gt;OpenDevice(id);
      std::optional&lt;Xt::Mix&gt; mix = device-&gt;GetMix();
      std::cout &lt;&lt; &quot;    Device &quot; &lt;&lt; id &lt;&lt; &quot;:\n&quot;;
      std::cout &lt;&lt; &quot;      Name: &quot; &lt;&lt; list-&gt;GetName(id) &lt;&lt; &quot;\n&quot;;
      std::cout &lt;&lt; &quot;      Capabilities: &quot; &lt;&lt; list-&gt;GetCapabilities(id) &lt;&lt; &quot;\n&quot;;
      std::cout &lt;&lt; &quot;      Input channels: &quot; &lt;&lt; device-&gt;GetChannelCount(false) &lt;&lt; &quot;\n&quot;;
      std::cout &lt;&lt; &quot;      Output channels: &quot; &lt;&lt; device-&gt;GetChannelCount(true) &lt;&lt; &quot;\n&quot;;
      std::cout &lt;&lt; &quot;      Interleaved access: &quot; &lt;&lt; device-&gt;SupportsAccess(true) &lt;&lt; &quot;\n&quot;;
      std::cout &lt;&lt; &quot;      Non-interleaved access: &quot; &lt;&lt; device-&gt;SupportsAccess(false) &lt;&lt; &quot;\n&quot;;
      if(mix) std::cout &lt;&lt; &quot;      Current mix: &quot; &lt;&lt; mix-&gt;rate &lt;&lt; &quot; &quot; &lt;&lt; mix-&gt;sample &lt;&lt; &quot;\n&quot;;
    } catch(std::exception const&amp; e)
    { std::cout &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;; }
  }
}

int 
PrintDetailedMain()
{
  Xt::Audio::SetOnError(OnError);
  std::unique_ptr&lt;Xt::Platform&gt; platform = Xt::Audio::Init(&quot;&quot;, nullptr);
  try 
  {
    Xt::Version version = Xt::Audio::GetVersion();
    std::cout &lt;&lt; &quot;Version: &quot; &lt;&lt; version.major &lt;&lt; &quot;.&quot; &lt;&lt; version.minor &lt;&lt; &quot;\n&quot;;    
    Xt::System pro = platform-&gt;SetupToSystem(Xt::Setup::ProAudio);
    std::cout &lt;&lt; &quot;Pro Audio: &quot; &lt;&lt; pro &lt;&lt; &quot; (&quot; &lt;&lt; (platform-&gt;GetService(pro) != nullptr) &lt;&lt; &quot;)\n&quot;;
    Xt::System system = platform-&gt;SetupToSystem(Xt::Setup::SystemAudio);
    std::cout &lt;&lt; &quot;System Audio: &quot; &lt;&lt; system &lt;&lt; &quot; (&quot; &lt;&lt; (platform-&gt;GetService(system) != nullptr) &lt;&lt; &quot;)\n&quot;;
    Xt::System consumer = platform-&gt;SetupToSystem(Xt::Setup::ConsumerAudio);
    std::cout &lt;&lt; &quot;Consumer Audio: &quot; &lt;&lt; consumer &lt;&lt; &quot; (&quot; &lt;&lt; (platform-&gt;GetService(consumer) != nullptr) &lt;&lt; &quot;)\n&quot;;

    for(Xt::System s: platform-&gt;GetSystems()) 
    {
      std::unique_ptr&lt;Xt::Service&gt; service = platform-&gt;GetService(s);
      std::unique_ptr&lt;Xt::DeviceList&gt; all = service-&gt;OpenDeviceList(Xt::EnumFlagsAll);
      std::cout &lt;&lt; &quot;System &quot; &lt;&lt; s &lt;&lt; &quot;:\n&quot;;
      std::cout &lt;&lt; &quot;  Capabilities: &quot; &lt;&lt; service-&gt;GetCapabilities() &lt;&lt; &quot;\n&quot;;
      std::optional&lt;std::string&gt; defaultInput = service-&gt;GetDefaultDeviceId(false);
      if(defaultInput.has_value())
      {
        std::string name = all-&gt;GetName(defaultInput.value());
        std::cout &lt;&lt; &quot;  Default input: &quot; &lt;&lt; name &lt;&lt; &quot; (&quot; &lt;&lt; defaultInput.value() &lt;&lt; &quot;)\n&quot;;
      }
      std::optional&lt;std::string&gt; defaultOutput = service-&gt;GetDefaultDeviceId(true);
      if(defaultOutput.has_value())
      {
        std::string name = all-&gt;GetName(defaultOutput.value());
        std::cout &lt;&lt; &quot;  Default output: &quot; &lt;&lt; name &lt;&lt; &quot; (&quot; &lt;&lt; defaultOutput.value() &lt;&lt; &quot;)\n&quot;;
      }
      std::unique_ptr&lt;Xt::DeviceList&gt; inputs = service-&gt;OpenDeviceList(Xt::EnumFlagsInput);
      std::cout &lt;&lt; &quot;  Input device count: &quot; &lt;&lt; inputs-&gt;GetCount() &lt;&lt; &quot;\n&quot;;
      PrintDevices(service.get(), inputs.get());
      std::unique_ptr&lt;Xt::DeviceList&gt; outputs = service-&gt;OpenDeviceList(Xt::EnumFlagsOutput);
      std::cout &lt;&lt; &quot;  Output device count: &quot; &lt;&lt; outputs-&gt;GetCount() &lt;&lt; &quot;\n&quot;;
      PrintDevices(service.get(), outputs.get());
    }
    return EXIT_SUCCESS;
  } catch(std::exception const&amp; e)
  {
    std::cout &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;; 
    return EXIT_FAILURE;
  }
}</code></pre>
            </div>
          </div>
        </div>
        <div class="tab-pane" id="simple-playback">
          <ul class="nav nav-tabs">
            <li><a href="#simple-playback-java" data-toggle="tab">Java</a></li>
            <li><a href="#simple-playback-net" data-toggle="tab">.NET</a></li>
            <li><a href="#simple-playback-cpp" data-toggle="tab">C++</a></li>
          </ul>
          <div class="usage">
            <br/>
            &bull; Render sinewave to the default output device.
          </div>
          <div class="tab-content">
            <div class="tab-pane" id="simple-playback-java">
              <pre><code class="lang-java">package xt.sample;

import xt.audio.Enums.XtSample;
import xt.audio.Enums.XtSetup;
import xt.audio.Enums.XtSystem;
import xt.audio.Structs.XtBuffer;
import xt.audio.Structs.XtBufferSize;
import xt.audio.Structs.XtChannels;
import xt.audio.Structs.XtDeviceStreamParams;
import xt.audio.Structs.XtFormat;
import xt.audio.Structs.XtMix;
import xt.audio.Structs.XtStreamParams;
import xt.audio.XtAudio;
import xt.audio.XtDevice;
import xt.audio.XtPlatform;
import xt.audio.XtSafeBuffer;
import xt.audio.XtService;
import xt.audio.XtStream;

public class RenderSimple {

    static float _phase = 0.0f;
    static final float FREQUENCY = 440.0f;
    static final XtMix MIX = new XtMix(44100, XtSample.FLOAT32);
    static final XtChannels CHANNELS = new XtChannels(0, 0, 1, 0);
    static final XtFormat FORMAT = new XtFormat(MIX, CHANNELS);

    static float nextSample() {
        _phase += FREQUENCY / FORMAT.mix.rate;
        if(_phase &gt;= 1.0f) _phase = -1.0f;
        return (float)Math.sin(2.0 * _phase * Math.PI);
    }

    static int onBuffer(XtStream stream, XtBuffer buffer, Object user) {
        XtSafeBuffer safe = XtSafeBuffer.get(stream);
        safe.lock(buffer);
        float[] output = (float[])safe.getOutput();
        for(int f = 0; f &lt; buffer.frames; f++) output[f] = nextSample();
        safe.unlock(buffer);
        return 0;
    }

    public static void main() throws Exception {
        XtStreamParams streamParams;
        XtDeviceStreamParams deviceParams;

        try(XtPlatform platform = XtAudio.init(null, null)) {
            XtSystem system = platform.setupToSystem(XtSetup.CONSUMER_AUDIO);
            XtService service = platform.getService(system);
            if(service == null) return;

            String defaultOutput = service.getDefaultDeviceId(true);
            if(defaultOutput == null) return;
            try(XtDevice device = service.openDevice(defaultOutput)) {
                if(!device.supportsFormat(FORMAT)) return;

                XtBufferSize size = device.getBufferSize(FORMAT);
                streamParams = new XtStreamParams(true, RenderSimple::onBuffer, null, null);
                deviceParams = new XtDeviceStreamParams(streamParams, FORMAT, size.current);
                try(XtStream stream = device.openStream(deviceParams, null);
                    XtSafeBuffer safe = XtSafeBuffer.register(stream)) {
                    stream.start();
                    Thread.sleep(2000);
                    stream.stop();
                }
            }
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="simple-playback-net">
              <pre><code class="lang-cs">using System;
using System.Threading;

namespace Xt
{
    public class RenderSimple
    {
        static float _phase;
        const float Frequency = 440.0f;
        static readonly XtMix Mix = new XtMix(44100, XtSample.Float32);
        static readonly XtChannels Channels = new XtChannels(0, 0, 1, 0);
        static readonly XtFormat Format = new XtFormat(Mix, Channels);

        static float NextSample()
        {
            _phase += Frequency / Mix.rate;
            if (_phase &gt;= 1.0f) _phase = -1.0f;
            return (float)Math.Sin(2.0 * _phase * Math.PI);
        }

        static int OnBuffer(XtStream stream, in XtBuffer buffer, object user)
        {
            XtSafeBuffer safe = XtSafeBuffer.Get(stream);
            safe.Lock(in buffer);
            float[] output = (float[])safe.GetOutput();
            for (int f = 0; f &lt; buffer.frames; f++) output[f] = NextSample();
            safe.Unlock(in buffer);
            return 0;
        }

        [STAThread]
        public static void Main()
        {
            XtStreamParams streamParams;
            XtDeviceStreamParams deviceParams;

            using XtPlatform platform = XtAudio.Init(null, IntPtr.Zero);
            XtSystem system = platform.SetupToSystem(XtSetup.ConsumerAudio);
            XtService service = platform.GetService(system);
            if (service == null) return;

            string defaultOutput = service.GetDefaultDeviceId(true);
            if(defaultOutput == null) return;
            using XtDevice device = service.OpenDevice(defaultOutput);
            if (!device.SupportsFormat(Format)) return;

            XtBufferSize size = device.GetBufferSize(Format);
            streamParams = new XtStreamParams(true, OnBuffer, null, null);
            deviceParams = new XtDeviceStreamParams(in streamParams, in Format, size.current);
            using XtStream stream = device.OpenStream(in deviceParams, null);
            using XtSafeBuffer safe = XtSafeBuffer.Register(stream);
            stream.Start();
            Thread.Sleep(2000);
            stream.Stop();
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="simple-playback-cpp">
              <pre><code class="lang-cpp">#define _USE_MATH_DEFINES 1
#include &lt;xt/XtAudio.hpp&gt;

#include &lt;cmath&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;cstdint&gt;

static float _phase = 0.0f;
static float const Frequency = 440.0f;
static Xt::Channels const Channels(0, 0, 1, 0);
static Xt::Mix const Mix(44100, Xt::Sample::Float32);
static Xt::Format const Format(Mix, Channels);

static float 
NextSample()
{
  _phase += Frequency / Mix.rate;
  if (_phase &gt;= 1.0f) _phase = -1.0f;
  return sinf(2.0f * _phase * static_cast&lt;float&gt;(M_PI));
}

static uint32_t 
OnBuffer(Xt::Stream const&amp; stream, Xt::Buffer const&amp; buffer, void* user)
{
  float* output = static_cast&lt;float*&gt;(buffer.output);
  for (int32_t f = 0; f &lt; buffer.frames; f++) output[f] = NextSample();
  return 0;
}

int 
RenderSimpleMain()
{
  std::unique_ptr&lt;Xt::Platform&gt; platform = Xt::Audio::Init(&quot;&quot;, nullptr);
  Xt::System system = platform-&gt;SetupToSystem(Xt::Setup::ConsumerAudio);
  std::unique_ptr&lt;Xt::Service&gt; service = platform-&gt;GetService(system);
  if (!service) return 0;

  std::optional&lt;std::string&gt; id = service-&gt;GetDefaultDeviceId(true);
  if(!id.has_value()) return 0;
  std::unique_ptr&lt;Xt::Device&gt; device = service-&gt;OpenDevice(id.value());
  if(!device-&gt;SupportsFormat(Format)) return 0;

  double bufferSize = device-&gt;GetBufferSize(Format).current;
  Xt::StreamParams streamParams(true, OnBuffer, nullptr, nullptr);
  Xt::DeviceStreamParams deviceParams(streamParams, Format, bufferSize);
  std::unique_ptr&lt;Xt::Stream&gt; stream = device-&gt;OpenStream(deviceParams, nullptr);
  stream-&gt;Start();
  std::this_thread::sleep_for(std::chrono::seconds(2));
  stream-&gt;Stop();

  return 0;
}</code></pre>
            </div>
          </div>
        </div>
        <div class="tab-pane" id="simple-record">
          <ul class="nav nav-tabs">
            <li><a href="#simple-record-java" data-toggle="tab">Java</a></li>
            <li><a href="#simple-record-net" data-toggle="tab">.NET</a></li>
            <li><a href="#simple-record-cpp" data-toggle="tab">C++</a></li>
          </ul>
          <div class="usage">
            <br/>
            &bull; Record from the default input device to a raw audio file.
          </div>
          <div class="tab-content">
            <div class="tab-pane" id="simple-record-java">
              <pre><code class="lang-java">package xt.sample;

import xt.audio.Enums.XtSample;
import xt.audio.Enums.XtSetup;
import xt.audio.Enums.XtSystem;
import xt.audio.Structs.XtBuffer;
import xt.audio.Structs.XtBufferSize;
import xt.audio.Structs.XtChannels;
import xt.audio.Structs.XtDeviceStreamParams;
import xt.audio.Structs.XtFormat;
import xt.audio.Structs.XtMix;
import xt.audio.Structs.XtStreamParams;
import xt.audio.XtAudio;
import xt.audio.XtDevice;
import xt.audio.XtPlatform;
import xt.audio.XtSafeBuffer;
import xt.audio.XtService;
import xt.audio.XtStream;
import java.io.FileOutputStream;

public class CaptureSimple {

    static final XtMix MIX = new XtMix(44100, XtSample.INT24);
    static final XtChannels CHANNELS = new XtChannels(1, 0, 0, 0);
    static final XtFormat FORMAT = new XtFormat(MIX, CHANNELS);

    // Normally don&#39;t do I/O in the callback.
    static int onBuffer(XtStream stream, XtBuffer buffer, Object user) throws Exception {
        var output = (FileOutputStream)user;
        XtSafeBuffer safe = XtSafeBuffer.get(stream);
        safe.lock(buffer);
        var input = (byte[])safe.getInput();
        int size = XtAudio.getSampleAttributes(MIX.sample).size;
        output.write(input, 0, buffer.frames * size);
        safe.unlock(buffer);
        return 0;
    }

    public static void main() throws Exception {
        XtStreamParams streamParams;
        XtDeviceStreamParams deviceParams;

        try(XtPlatform platform = XtAudio.init(null, null)) {
            XtSystem system = platform.setupToSystem(XtSetup.CONSUMER_AUDIO);
            XtService service = platform.getService(system);
            if(service == null) return;

            String defaultInput = service.getDefaultDeviceId(false);
            if(defaultInput == null) return;
            try(XtDevice device = service.openDevice(defaultInput)) {
                if(!device.supportsFormat(FORMAT)) return;

                XtBufferSize size = device.getBufferSize(FORMAT);
                streamParams = new XtStreamParams(true, CaptureSimple::onBuffer, null, null);
                deviceParams = new XtDeviceStreamParams(streamParams, FORMAT, size.current);
                try(FileOutputStream recording = new FileOutputStream(&quot;xt-audio.raw&quot;);
                    XtStream stream = device.openStream(deviceParams, recording);
                    XtSafeBuffer safe = XtSafeBuffer.register(stream)) {
                    stream.start();
                    Thread.sleep(2000);
                    stream.stop();
                }
            }
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="simple-record-net">
              <pre><code class="lang-cs">using System;
using System.IO;
using System.Threading;

namespace Xt
{
    public class CaptureSimple
    {
        static readonly XtMix Mix = new XtMix(44100, XtSample.Int24);
        static readonly XtChannels Channels = new XtChannels(1, 0, 0, 0);
        static readonly XtFormat Format = new XtFormat(Mix, Channels);

        // Normally don&#39;t do I/O in the callback.
        static int OnBuffer(XtStream stream, in XtBuffer buffer, object user)
        {
            var output = (FileStream)user;
            XtSafeBuffer safe = XtSafeBuffer.Get(stream);
            safe.Lock(buffer);
            var input = (byte[])safe.GetInput();
            int size = XtAudio.GetSampleAttributes(Mix.sample).size;
            if (buffer.frames &gt; 0) output.Write(input, 0, buffer.frames * size);
            safe.Unlock(buffer);
            return 0;
        }

        [STAThread]
        public static void Main()
        {
            XtStreamParams streamParams;
            XtDeviceStreamParams deviceParams;

            using XtPlatform platform = XtAudio.Init(null, IntPtr.Zero);
            XtSystem system = platform.SetupToSystem(XtSetup.ConsumerAudio);
            XtService service = platform.GetService(system);
            if (service == null) return;

            string defaultInput = service.GetDefaultDeviceId(false);
            if(defaultInput == null) return;
            using XtDevice device = service.OpenDevice(defaultInput);
            if (!device.SupportsFormat(Format)) return;

            XtBufferSize size = device.GetBufferSize(Format);
            streamParams = new XtStreamParams(true, OnBuffer, null, null);
            deviceParams = new XtDeviceStreamParams(in streamParams, in Format, size.current);
            using var recording = new FileStream(&quot;xt-audio.raw&quot;, FileMode.Create, FileAccess.Write);
            using XtStream stream = device.OpenStream(in deviceParams, recording);
            using XtSafeBuffer safe = XtSafeBuffer.Register(stream);
            stream.Start();
            Thread.Sleep(2000);
            stream.Stop();
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="simple-record-cpp">
              <pre><code class="lang-cpp">#include &lt;xt/XtAudio.hpp&gt;

#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;fstream&gt;

static Xt::Channels const Channels(1, 0, 0, 0);
static Xt::Mix const Mix(44100, Xt::Sample::Int24);
static Xt::Format const Format(Mix, Channels);

// Normally don&#39;t do I/O in the callback.
static uint32_t 
OnBuffer(Xt::Stream const&amp; stream, Xt::Buffer const&amp; buffer, void* user) 
{
  auto os = static_cast&lt;std::ofstream*&gt;(user);
  char const* input = static_cast&lt;char const*&gt;(buffer.input);
  int32_t bytes = Xt::Audio::GetSampleAttributes(Mix.sample).size * buffer.frames;
  os-&gt;write(input, bytes);
  return 0;
}

int 
CaptureSimpleMain() 
{
  std::unique_ptr&lt;Xt::Platform&gt; platform = Xt::Audio::Init(&quot;&quot;, nullptr);
  Xt::System system = platform-&gt;SetupToSystem(Xt::Setup::ConsumerAudio);
  std::unique_ptr&lt;Xt::Service&gt; service = platform-&gt;GetService(system);
  if(!service) return 0;  

  std::optional&lt;std::string&gt; id = service-&gt;GetDefaultDeviceId(false);
  if(!id.has_value()) return 0;
  std::unique_ptr&lt;Xt::Device&gt; device = service-&gt;OpenDevice(id.value());
  if(!device-&gt;SupportsFormat(Format)) return 0;

  double bufferSize = device-&gt;GetBufferSize(Format).current;
  Xt::StreamParams streamParams(true, OnBuffer, nullptr, nullptr);
  Xt::DeviceStreamParams deviceParams(streamParams, Format, bufferSize);
  std::ofstream recording(&quot;xt-audio.raw&quot;, std::ios::out | std::ios::binary);
  std::unique_ptr&lt;Xt::Stream&gt; stream = device-&gt;OpenStream(deviceParams, &amp;recording);
  stream-&gt;Start();
  std::this_thread::sleep_for(std::chrono::seconds(2));
  stream-&gt;Stop();

  return 0;
}</code></pre>
            </div>
          </div>
        </div>
        <div class="tab-pane" id="advanced-playback">
          <ul class="nav nav-tabs">
            <li><a href="#advanced-playback-java" data-toggle="tab">Java</a></li>
            <li><a href="#advanced-playback-net" data-toggle="tab">.NET</a></li>
            <li><a href="#advanced-playback-cpp" data-toggle="tab">C++</a></li>
          </ul>
          <div class="usage">
            <br/>
            &bull; Get notified on stream under/overflow.<br/>
            &bull; Playback using interleaved and non-interleaved buffers.<br/>
            &bull; Get notified when the stream stops outside of application's control.<br/>
            &bull; Use channel masks to route a channel to a specific speaker position.<br/>
            &bull; (Java and .NET): use native buffers to prevent data copying or safe buffers to work with .NET/JVM arrays instead of raw pointers.
          </div>
          <div class="tab-content">
            <div class="tab-pane" id="advanced-playback-java">
              <pre><code class="lang-java">package xt.sample;

import com.sun.jna.Native;
import xt.audio.Enums.XtSample;
import xt.audio.Enums.XtSetup;
import xt.audio.Enums.XtSystem;
import xt.audio.Structs.XtBuffer;
import xt.audio.Structs.XtBufferSize;
import xt.audio.Structs.XtChannels;
import xt.audio.Structs.XtDeviceStreamParams;
import xt.audio.Structs.XtFormat;
import xt.audio.Structs.XtMix;
import xt.audio.Structs.XtStreamParams;
import xt.audio.XtAudio;
import xt.audio.XtDevice;
import xt.audio.XtPlatform;
import xt.audio.XtSafeBuffer;
import xt.audio.XtService;
import xt.audio.XtStream;

public class RenderAdvanced {

    static float _phase = 0.0f;
    static final float FREQUENCY = 440.0f;
    static final XtMix MIX = new XtMix(44100, XtSample.FLOAT32);

    static float nextSample() {
        _phase += FREQUENCY / MIX.rate;
        if(_phase &gt;= 1.0) _phase = -1.0f;
        return (float)Math.sin(2.0 * _phase * Math.PI);
    }

    // Normally don&#39;t do I/O in the callback.
    static void onXRun(XtStream stream, int index, Object user) {
        System.out.println(&quot;XRun on device &quot; + index + &quot;.&quot;);
    }

    static void onRunning(XtStream stream, boolean running, long error, Object user) {
        String evt = running? &quot;Started&quot;: &quot;Stopped&quot;;
        System.out.println(&quot;Stream event: &quot; + evt + &quot;, new state: &quot; + stream.isRunning() + &quot;.&quot;);
        if(error != 0) System.out.println(XtAudio.getErrorInfo(error).toString());
    }

    static void runStream(XtStream stream) throws Exception {
        stream.start();
        Thread.sleep(2000);
        stream.stop();
    }

    static int onInterleavedSafeBuffer(XtStream stream, XtBuffer buffer, Object user) throws Exception {
        XtSafeBuffer safe = XtSafeBuffer.get(stream);
        int channels = stream.getFormat().channels.outputs;
        safe.lock(buffer);
        float[] output = (float[])safe.getOutput();
        for(int f = 0; f &lt; buffer.frames; f++) {
            float sample = nextSample();
            for(int c = 0; c &lt; channels; c++) output[f * channels + c] = sample;
        }
        safe.unlock(buffer);
        return 0;
    }

    static int onInterleavedNativeBuffer(XtStream stream, XtBuffer buffer, Object user) throws Exception {
        int channels = stream.getFormat().channels.outputs;
        int size = XtAudio.getSampleAttributes(MIX.sample).size;
        for(int f = 0; f &lt; buffer.frames; f++) {
            float sample = nextSample();
            for(int c = 0; c &lt; channels; c++)
                buffer.output.setFloat((f * channels + c) * size, sample);
        }
        return 0;
    }

    static int onNonInterleavedSafeBuffer(XtStream stream, XtBuffer buffer, Object user) throws Exception {
        XtSafeBuffer safe = XtSafeBuffer.get(stream);
        int channels = stream.getFormat().channels.outputs;
        safe.lock(buffer);
        float[][] output = (float[][])safe.getOutput();
        for(int f = 0; f &lt; buffer.frames; f++) {
            float sample = nextSample();
            for(int c = 0; c &lt; channels; c++) output[c][f] = sample;
        }
        safe.unlock(buffer);
        return 0;
    }

    static int onNonInterleavedNativeBuffer(XtStream stream, XtBuffer buffer, Object user) throws Exception {
        int channels = stream.getFormat().channels.outputs;
        int size = XtAudio.getSampleAttributes(MIX.sample).size;
        for(int f = 0; f &lt; buffer.frames; f++) {
            float sample = nextSample();
            for(int c = 0; c &lt; channels; c++)
                buffer.output.getPointer(c * Native.POINTER_SIZE).setFloat(f * size, sample);
        }
        return 0;
    }

    public static void main() throws Exception {
        XtStreamParams streamParams;
        XtDeviceStreamParams deviceParams;

        try(XtPlatform platform = XtAudio.init(null, null)) {
            XtSystem system = platform.setupToSystem(XtSetup.CONSUMER_AUDIO);
            XtService service = platform.getService(system);
            if(service == null) return;

            String defaultOutput = service.getDefaultDeviceId(true);
            if(defaultOutput == null) return;
            XtFormat format = new XtFormat(MIX, new XtChannels(0, 0, 2, 0));
            try(XtDevice device = service.openDevice(defaultOutput)) {
                if(!device.supportsFormat(format)) return;
                XtBufferSize size = device.getBufferSize(format);

                System.out.println(&quot;Render interleaved, safe buffers...&quot;);
                streamParams = new XtStreamParams(true, RenderAdvanced::onInterleavedSafeBuffer, RenderAdvanced::onXRun, RenderAdvanced::onRunning);
                deviceParams = new XtDeviceStreamParams(streamParams, format, size.current);
                try(XtStream stream = device.openStream(deviceParams, null);
                    XtSafeBuffer safe = XtSafeBuffer.register(stream)) {
                    runStream(stream);
                }

                System.out.println(&quot;Render interleaved, native buffers...&quot;);
                streamParams = new XtStreamParams(true, RenderAdvanced::onInterleavedNativeBuffer, RenderAdvanced::onXRun, RenderAdvanced::onRunning);
                deviceParams = new XtDeviceStreamParams(streamParams, format, size.current);
                try(XtStream stream = device.openStream(deviceParams, null)) {
                    runStream(stream);
                }

                System.out.println(&quot;Render non-interleaved, safe buffers...&quot;);
                streamParams = new XtStreamParams(false, RenderAdvanced::onNonInterleavedSafeBuffer, RenderAdvanced::onXRun, RenderAdvanced::onRunning);
                deviceParams = new XtDeviceStreamParams(streamParams, format, size.current);
                try(XtStream stream = device.openStream(deviceParams, null);
                    XtSafeBuffer safe = XtSafeBuffer.register(stream)) {
                    runStream(stream);
                }

                System.out.println(&quot;Render non-interleaved, native buffers...&quot;);
                streamParams = new XtStreamParams(false, RenderAdvanced::onNonInterleavedNativeBuffer, RenderAdvanced::onXRun, RenderAdvanced::onRunning);
                deviceParams = new XtDeviceStreamParams(streamParams, format, size.current);
                try(XtStream stream = device.openStream(deviceParams, null)) {
                    runStream(stream);
                }

                System.out.println(&quot;Render interleaved, safe buffers (channel 0)...&quot;);
                XtFormat sendTo0 = new XtFormat(MIX, new XtChannels(0, 0, 1, 1L &lt;&lt; 0));
                streamParams = new XtStreamParams(true, RenderAdvanced::onInterleavedSafeBuffer, RenderAdvanced::onXRun, RenderAdvanced::onRunning);
                deviceParams = new XtDeviceStreamParams(streamParams, sendTo0, size.current);
                try(XtStream stream = device.openStream(deviceParams, null);
                    XtSafeBuffer safe = XtSafeBuffer.register(stream)) {
                    runStream(stream);
                }

                System.out.println(&quot;Render non-interleaved, native buffers (channel 1)...&quot;);
                XtFormat sendTo1 = new XtFormat(MIX, new XtChannels(0, 0, 1, 1L &lt;&lt; 1));
                streamParams = new XtStreamParams(false, RenderAdvanced::onNonInterleavedNativeBuffer, RenderAdvanced::onXRun, RenderAdvanced::onRunning);
                deviceParams = new XtDeviceStreamParams(streamParams, sendTo1, size.current);
                try(XtStream stream = device.openStream(deviceParams, null)) {
                    runStream(stream);
                }
            }
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="advanced-playback-net">
              <pre><code class="lang-cs">using System;
using System.Threading;

namespace Xt
{
    public class RenderAdvanced
    {
        static float _phase = 0.0f;
        const float Frequency = 440.0f;
        static readonly XtMix Mix = new XtMix(44100, XtSample.Float32);

        static float NextSample()
        {
            _phase += Frequency / Mix.rate;
            if (_phase &gt;= 1.0f) _phase = -1.0f;
            return (float)Math.Sin(2.0 * _phase * Math.PI);
        }

        // Normally don&#39;t do I/O in the callback.
        static void OnXRun(XtStream stream, int index, object user)
        =&gt; Console.WriteLine(&quot;XRun on device &quot; + index + &quot;.&quot;);

        static void OnRunning(XtStream stream, bool running, ulong error, object user)
        {
            string evt = running ? &quot;Started&quot; : &quot;Stopped&quot;;
            Console.WriteLine(&quot;Stream event: &quot; + evt + &quot;, new state: &quot; + stream.IsRunning() + &quot;.&quot;);
            if (error != 0) Console.WriteLine(XtAudio.GetErrorInfo(error).ToString());
        }

        static void RunStream(XtStream stream)
        {
            stream.Start();
            Thread.Sleep(2000);
            stream.Stop();
        }

        static int OnInterleavedSafeBuffer(XtStream stream, in XtBuffer buffer, object user)
        {
            XtSafeBuffer safe = XtSafeBuffer.Get(stream);
            int channels = stream.GetFormat().channels.outputs;
            safe.Lock(in buffer);
            float[] output = (float[])safe.GetOutput();
            for (int f = 0; f &lt; buffer.frames; f++)
            {
                float sample = NextSample();
                for (int c = 0; c &lt; channels; c++) output[f * channels + c] = sample;
            }
            safe.Unlock(buffer);
            return 0;
        }

        static unsafe int OnInterleavedNativeBuffer(XtStream stream, in XtBuffer buffer, object user)
        {
            int channels = stream.GetFormat().channels.outputs;
            int size = XtAudio.GetSampleAttributes(Mix.sample).size;
            for (int f = 0; f &lt; buffer.frames; f++)
            {
                float sample = NextSample();
                for (int c = 0; c &lt; channels; c++) ((float*)buffer.output)[f * channels + c] = sample;
            }
            return 0;
        }

        static int OnNonInterleavedSafeBuffer(XtStream stream, in XtBuffer buffer, object user)
        {
            XtSafeBuffer safe = XtSafeBuffer.Get(stream);
            int channels = stream.GetFormat().channels.outputs;
            safe.Lock(buffer);
            float[][] output = (float[][])safe.GetOutput();
            for (int f = 0; f &lt; buffer.frames; f++)
            {
                float sample = NextSample();
                for (int c = 0; c &lt; channels; c++) output[c][f] = sample;
            }
            safe.Unlock(buffer);
            return 0;
        }

        static unsafe int OnNonInterleavedNativeBuffer(XtStream stream, in XtBuffer buffer, object user)
        {
            int channels = stream.GetFormat().channels.outputs;
            int size = XtAudio.GetSampleAttributes(Mix.sample).size;
            for (int f = 0; f &lt; buffer.frames; f++)
            {
                float sample = NextSample();
                for (int c = 0; c &lt; channels; c++) ((float**)buffer.output)[c][f] = sample;
            }
            return 0;
        }

        [STAThread]
        public static void Main()
        {
            XtStreamParams streamParams;
            XtDeviceStreamParams deviceParams;

            using XtPlatform platform = XtAudio.Init(null, IntPtr.Zero);
            XtSystem system = platform.SetupToSystem(XtSetup.ConsumerAudio);
            XtService service = platform.GetService(system);
            if (service == null) return;

            XtFormat format = new XtFormat(Mix, new XtChannels(0, 0, 2, 0));
            string defaultOutput = service.GetDefaultDeviceId(true);
            if (defaultOutput == null) return;
            using XtDevice device = service.OpenDevice(defaultOutput);
            if (!device.SupportsFormat(format)) return;
            XtBufferSize size = device.GetBufferSize(format);

            Console.WriteLine(&quot;Render interleaved, safe buffers...&quot;);
            streamParams = new XtStreamParams(true, OnInterleavedSafeBuffer, OnXRun, OnRunning);
            deviceParams = new XtDeviceStreamParams(in streamParams, in format, size.current);
            using (XtStream stream = device.OpenStream(in deviceParams, null))
            using (XtSafeBuffer safe = XtSafeBuffer.Register(stream))
                RunStream(stream);

            Console.WriteLine(&quot;Render interleaved, native buffers...&quot;);
            streamParams = new XtStreamParams(true, OnInterleavedNativeBuffer, OnXRun, OnRunning);
            deviceParams = new XtDeviceStreamParams(in streamParams, in format, size.current);
            using (XtStream stream = device.OpenStream(in deviceParams, null))
                RunStream(stream);

            Console.WriteLine(&quot;Render non-interleaved, safe buffers...&quot;);
            streamParams = new XtStreamParams(false, OnNonInterleavedSafeBuffer, OnXRun, OnRunning);
            deviceParams = new XtDeviceStreamParams(in streamParams, in format, size.current);
            using (XtStream stream = device.OpenStream(in deviceParams, null))
            using (XtSafeBuffer safe = XtSafeBuffer.Register(stream))
                RunStream(stream);

            Console.WriteLine(&quot;Render non-interleaved, native buffers...&quot;);
            streamParams = new XtStreamParams(false, OnNonInterleavedNativeBuffer, OnXRun, OnRunning);
            deviceParams = new XtDeviceStreamParams(in streamParams, in format, size.current);
            using (XtStream stream = device.OpenStream(in deviceParams, null))
                RunStream(stream);

            Console.WriteLine(&quot;Render interleaved, safe buffers (channel 0)...&quot;);
            XtFormat sendTo0 = new XtFormat(Mix, new XtChannels(0, 0, 1, 1L &lt;&lt; 0));
            streamParams = new XtStreamParams(true, OnInterleavedSafeBuffer, OnXRun, OnRunning);
            deviceParams = new XtDeviceStreamParams(in streamParams, in sendTo0, size.current);
            using (XtStream stream = device.OpenStream(in deviceParams, null))
            using (XtSafeBuffer safe = XtSafeBuffer.Register(stream))
                RunStream(stream);

            Console.WriteLine(&quot;Render non-interleaved, native buffers (channel 1)...&quot;);
            XtFormat sendTo1 = new XtFormat(Mix, new XtChannels(0, 0, 1, 1L &lt;&lt; 1));
            streamParams = new XtStreamParams(false, OnNonInterleavedNativeBuffer, OnXRun, OnRunning);
            deviceParams = new XtDeviceStreamParams(in streamParams, in sendTo1, size.current);
            using (XtStream stream = device.OpenStream(in deviceParams, null))
                RunStream(stream);
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="advanced-playback-cpp">
              <pre><code class="lang-cpp">#define _USE_MATH_DEFINES 1
#include &lt;xt/XtAudio.hpp&gt;

#include &lt;cmath&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

static float _phase = 0.0f;
static float const Frequency = 440.0f;
static Xt::Mix const Mix(44100, Xt::Sample::Float32);

// Normally don&#39;t do I/O in the callback.
static void 
OnXRun(Xt::Stream const&amp; stream, int32_t index, void* user) 
{ std::cout &lt;&lt; &quot;XRun on device &quot; &lt;&lt; index &lt;&lt; &quot;.\n&quot;; }

static void
OnRunning(Xt::Stream const&amp; stream, bool running, uint64_t error, void* user)
{ 
  char const* evt = running? &quot;Started&quot;: &quot;Stopped&quot;;
  std::cout &lt;&lt; &quot;Stream event: &quot; &lt;&lt; evt &lt;&lt; &quot;, new state: &quot; &lt;&lt; stream.IsRunning() &lt;&lt; &quot;.\n&quot;; 
  if(error != 0) std::cout &lt;&lt; Xt::Audio::GetErrorInfo(error) &lt;&lt; &quot;.\n&quot;;
}

static void 
RunStream(Xt::Stream* stream)
{
  stream-&gt;Start();
  std::this_thread::sleep_for(std::chrono::seconds(2));
  stream-&gt;Stop();
}

static float 
NextSample()
{
  _phase += Frequency / Mix.rate;
  if (_phase &gt;= 1.0f) _phase = -1.0f;
  return sinf(2.0f * _phase * static_cast&lt;float&gt;(M_PI));
}

static uint32_t 
OnInterleavedBuffer(Xt::Stream const&amp; stream, Xt::Buffer const&amp; buffer, void* user)
{
  float* output = static_cast&lt;float*&gt;(buffer.output);
  int32_t channels = stream.GetFormat().channels.outputs;
  int32_t size = Xt::Audio::GetSampleAttributes(Mix.sample).size;
  for(int32_t f = 0; f &lt; buffer.frames; f++) 
  {
    float sample = NextSample();
    for (int32_t c = 0; c &lt; channels; c++) output[f * channels + c] = sample;
  }
  return 0;
}

static uint32_t 
OnNonInterleavedBuffer(Xt::Stream const&amp; stream, Xt::Buffer const&amp; buffer, void* user) 
{
  float** output = static_cast&lt;float**&gt;(buffer.output);
  int32_t channels = stream.GetFormat().channels.outputs;
  int32_t size = Xt::Audio::GetSampleAttributes(Mix.sample).size;
  for(int32_t f = 0; f &lt; buffer.frames; f++) 
  {
    float sample = NextSample();
    for(int32_t c = 0; c &lt; channels; c++) output[c][f] = sample;
  }
  return 0;
}

int 
RenderAdvancedMain() 
{
  std::unique_ptr&lt;Xt::Platform&gt; platform = Xt::Audio::Init(&quot;&quot;, nullptr);
  Xt::Format format(Mix, Xt::Channels(0, 0, 2, 0));
  Xt::System system = platform-&gt;SetupToSystem(Xt::Setup::ConsumerAudio);
  std::unique_ptr&lt;Xt::Service&gt; service = platform-&gt;GetService(system);
  if(!service) return 0;

  std::optional&lt;std::string&gt; id = service-&gt;GetDefaultDeviceId(true);
  if(!id.has_value()) return 0;
  std::unique_ptr&lt;Xt::Device&gt; device = service-&gt;OpenDevice(id.value());
  if (!device-&gt;SupportsFormat(format)) return 0;
  Xt::BufferSize size = device-&gt;GetBufferSize(format);

  std::cout &lt;&lt; &quot;Render interleaved...\n&quot;;
  Xt::StreamParams streamParams(true, OnInterleavedBuffer, OnXRun, OnRunning);
  Xt::DeviceStreamParams deviceParams(streamParams, format, size.current);
  {
    std::unique_ptr&lt;Xt::Stream&gt; stream = device-&gt;OpenStream(deviceParams, nullptr);
    RunStream(stream.get());
  }

  std::cout &lt;&lt; &quot;Render non-interleaved...\n&quot;;
  streamParams = Xt::StreamParams(false, OnNonInterleavedBuffer, OnXRun, OnRunning);
  deviceParams = Xt::DeviceStreamParams(streamParams, format, size.current);
  {
    std::unique_ptr&lt;Xt::Stream&gt; stream = device-&gt;OpenStream(deviceParams, nullptr);
    RunStream(stream.get());
  }

  std::cout &lt;&lt; &quot;Render interleaved (channel 0)...\n&quot;;
  Xt::Format sendTo0(Mix, Xt::Channels(0, 0, 1, 1ULL &lt;&lt; 0));
  streamParams = Xt::StreamParams(true, OnInterleavedBuffer, OnXRun, OnRunning);
  deviceParams = Xt::DeviceStreamParams(streamParams, sendTo0, size.current);
  {
    std::unique_ptr&lt;Xt::Stream&gt; stream = device-&gt;OpenStream(deviceParams, nullptr);
    RunStream(stream.get());
  }

  std::cout &lt;&lt; &quot;Render non-interleaved (channel 1)...\n&quot;;
  Xt::Format sendTo1(Mix, Xt::Channels(0, 0, 1, 1ULL &lt;&lt; 1));
  streamParams = Xt::StreamParams(false, OnNonInterleavedBuffer, OnXRun, OnRunning);
  deviceParams = Xt::DeviceStreamParams(streamParams, sendTo1, size.current);
  {
    std::unique_ptr&lt;Xt::Stream&gt; stream = device-&gt;OpenStream(deviceParams, nullptr);
    RunStream(stream.get());
  }

  return 0;
}</code></pre>
            </div>
          </div>
        </div>
        <div class="tab-pane" id="advanced-record">
          <ul class="nav nav-tabs">
            <li><a href="#advanced-record-java" data-toggle="tab">Java</a></li>
            <li><a href="#advanced-record-net" data-toggle="tab">.NET</a></li>
            <li><a href="#advanced-record-cpp" data-toggle="tab">C++</a></li>
          </ul>
          <div class="usage">
            <br/>
            &bull; Get notified on stream under/overflow.<br/>
            &bull; Record using interleaved and non-interleaved buffers.<br/>
            &bull; Get notified when the stream stops outside of application's control.<br/>
            &bull; (Java and .NET): use native buffers to prevent data copying or safe buffers to work with .NET/JVM arrays instead of raw pointers.
          </div>
          <div class="tab-content">
            <div class="tab-pane" id="advanced-record-java">
              <pre><code class="lang-java">package xt.sample;

import com.sun.jna.Native;
import com.sun.jna.Pointer;

import xt.audio.Enums.XtSample;
import xt.audio.Enums.XtSetup;
import xt.audio.Enums.XtSystem;
import xt.audio.Structs.XtBuffer;
import xt.audio.Structs.XtBufferSize;
import xt.audio.Structs.XtChannels;
import xt.audio.Structs.XtDeviceStreamParams;
import xt.audio.Structs.XtFormat;
import xt.audio.Structs.XtMix;
import xt.audio.Structs.XtStreamParams;
import xt.audio.XtAudio;
import xt.audio.XtDevice;
import xt.audio.XtPlatform;
import xt.audio.XtSafeBuffer;
import xt.audio.XtService;
import xt.audio.XtStream;
import java.io.FileOutputStream;

public class CaptureAdvanced {

    static class Context {
        byte[] intermediate;
        FileOutputStream out;
    }

    static final XtMix MIX = new XtMix(44100, XtSample.INT24);
    static final XtChannels CHANNELS = new XtChannels(2, 0, 0, 0);
    static final XtFormat FORMAT = new XtFormat(MIX, CHANNELS);

    // Normally don&#39;t do I/O in the callback.
    static void onXRun(XtStream stream, int index, Object user) {
        System.out.println(&quot;XRun on device &quot; + index + &quot;.&quot;);
    }

    static void onRunning(XtStream stream, boolean running, long error, Object user) {
        String evt = running? &quot;Started&quot;: &quot;Stopped&quot;;
        System.out.println(&quot;Stream event: &quot; + evt + &quot;, new state: &quot; + stream.isRunning() + &quot;.&quot;);
        if(error != 0) System.out.println(XtAudio.getErrorInfo(error).toString());
    }

    static int getBufferSize(int channels, int frames) {
        int size = XtAudio.getSampleAttributes(MIX.sample).size;
        return channels * frames * size;
    }

    static void runStream(XtStream stream) throws Exception {
        stream.start();
        Thread.sleep(2000);
        stream.stop();
    }

    // Normally don&#39;t do I/O in the callback.
    static int onInterleavedSafeBuffer(XtStream stream, XtBuffer buffer, Object user) throws Exception {
        var out = (FileOutputStream)user;
        XtSafeBuffer safe = XtSafeBuffer.get(stream);
        int bytes = getBufferSize(CHANNELS.inputs, buffer.frames);
        safe.lock(buffer);
        out.write((byte[])safe.getInput(), 0, bytes);
        safe.unlock(buffer);
        return 0;
    }

    // Normally don&#39;t do I/O in the callback.
    static int onInterleavedNativeBuffer(XtStream stream, XtBuffer buffer, Object user) throws Exception {
        var ctx = (Context)user;
        int bytes = getBufferSize(CHANNELS.inputs, buffer.frames);
        buffer.input.read(0, ctx.intermediate, 0, bytes);
        ctx.out.write(ctx.intermediate, 0, bytes);
        return 0;
    }

    // Normally don&#39;t do I/O in the callback.
    static int onNonInterleavedSafeBuffer(XtStream stream, XtBuffer buffer, Object user) throws Exception {
        var out = (FileOutputStream)user;
        XtSafeBuffer safe = XtSafeBuffer.get(stream);
        int size = XtAudio.getSampleAttributes(MIX.sample).size;
        safe.lock(buffer);
        for(int f = 0; f &lt; buffer.frames; f++)
            for(int c = 0; c &lt; CHANNELS.inputs; c++)
                out.write(((byte[][])safe.getInput())[c], f * size, size);
        safe.unlock(buffer);
        return 0;
    }

    // Normally don&#39;t do I/O in the callback.
    static int onNonInterleavedNativeBuffer(XtStream stream, XtBuffer buffer, Object user) throws Exception {
        var ctx = (Context)user;
        int size = XtAudio.getSampleAttributes(MIX.sample).size;
        for(int f = 0; f &lt; buffer.frames; f++)
            for(int c = 0; c &lt; CHANNELS.inputs; c++) {
                Pointer channel = buffer.input.getPointer(c * Native.POINTER_SIZE);
                channel.read(f * size, ctx.intermediate, 0, size);
                ctx.out.write(ctx.intermediate, 0, size);
            }
        return 0;
    }

    public static void main() throws Exception {
        XtStreamParams streamParams;
        XtDeviceStreamParams deviceParams;

        try(XtPlatform platform = XtAudio.init(null, null)) {
            XtSystem system = platform.setupToSystem(XtSetup.CONSUMER_AUDIO);
            XtService service = platform.getService(system);
            if(service == null) return;

            String defaultInput = service.getDefaultDeviceId(false);
            if(defaultInput == null) return;
            try(XtDevice device = service.openDevice(defaultInput)) {
                if(!device.supportsFormat(FORMAT)) return;
                XtBufferSize size = device.getBufferSize(FORMAT);

                System.out.println(&quot;Capture interleaved, safe buffers...&quot;);
                streamParams = new XtStreamParams(true, CaptureAdvanced::onInterleavedSafeBuffer, CaptureAdvanced::onXRun, CaptureAdvanced::onRunning);
                deviceParams = new XtDeviceStreamParams(streamParams, FORMAT, size.current);
                try(FileOutputStream recording = new FileOutputStream(&quot;xt-audio-interleaved-safe.raw&quot;);
                    XtStream stream = device.openStream(deviceParams, recording);
                    XtSafeBuffer safe = XtSafeBuffer.register(stream)) {
                    runStream(stream);
                }

                System.out.println(&quot;Capture interleaved, native buffers...&quot;);
                streamParams = new XtStreamParams(true, CaptureAdvanced::onInterleavedNativeBuffer, CaptureAdvanced::onXRun, CaptureAdvanced::onRunning);
                deviceParams = new XtDeviceStreamParams(streamParams, FORMAT, size.current);
                Context context = new Context();
                try(FileOutputStream recording = new FileOutputStream(&quot;xt-audio-interleaved-native.raw&quot;);
                    XtStream stream = device.openStream(deviceParams, context)) {
                    context.out = recording;
                    context.intermediate = new byte[getBufferSize(CHANNELS.inputs, stream.getFrames())];
                    runStream(stream);
                }

                System.out.println(&quot;Capture non-interleaved, safe buffers...&quot;);
                streamParams = new XtStreamParams(false, CaptureAdvanced::onNonInterleavedSafeBuffer, CaptureAdvanced::onXRun, CaptureAdvanced::onRunning);
                deviceParams = new XtDeviceStreamParams(streamParams, FORMAT, size.current);
                try(FileOutputStream recording = new FileOutputStream(&quot;xt-audio-non-interleaved-safe.raw&quot;);
                    XtStream stream = device.openStream(deviceParams, recording);
                    XtSafeBuffer safe = XtSafeBuffer.register(stream)) {
                    runStream(stream);
                }

                System.out.println(&quot;Capture non-interleaved, native buffers...&quot;);
                context = new Context();
                streamParams = new XtStreamParams(false, CaptureAdvanced::onNonInterleavedNativeBuffer, CaptureAdvanced::onXRun, CaptureAdvanced::onRunning);
                deviceParams = new XtDeviceStreamParams(streamParams, FORMAT, size.current);
                try(FileOutputStream recording = new FileOutputStream(&quot;xt-audio-non-interleaved-native.raw&quot;);
                    XtStream stream = device.openStream(deviceParams, context)) {
                    context.out = recording;
                    context.intermediate = new byte[getBufferSize(1, stream.getFrames())];
                    runStream(stream);
                }
            }
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="advanced-record-net">
              <pre><code class="lang-cs">using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;

namespace Xt
{
    public class CaptureAdvanced
    {
        class Context
        {
            internal byte[] intermediate;
            internal FileStream recording;
        }

        static readonly XtMix Mix = new XtMix(44100, XtSample.Int24);
        static readonly XtChannels Channels = new XtChannels(2, 0, 0, 0);
        static readonly XtFormat Format = new XtFormat(Mix, Channels);

        // Normally don&#39;t do I/O in the callback.
        static void OnXRun(XtStream stream, int index, object user)
        =&gt; Console.WriteLine(&quot;XRun on device &quot; + index + &quot;.&quot;);

        static void OnRunning(XtStream stream, bool running, ulong error, object user)
        {
            string evt = running ? &quot;Started&quot; : &quot;Stopped&quot;;
            Console.WriteLine(&quot;Stream event: &quot; + evt + &quot;, new state: &quot; + stream.IsRunning() + &quot;.&quot;);
            if (error != 0) Console.WriteLine(XtAudio.GetErrorInfo(error).ToString());
        }

        static void RunStream(XtStream stream)
        {
            stream.Start();
            Thread.Sleep(2000);
            stream.Stop();
        }

        static int GetBufferSize(int channels, int frames)
        {
            int size = XtAudio.GetSampleAttributes(Mix.sample).size;
            return channels * frames * size;
        }

        // Normally don&#39;t do I/O in the callback.
        static int OnInterleavedSafeBuffer(XtStream stream, in XtBuffer buffer, object user)
        {
            var output = (FileStream)user;
            XtSafeBuffer safe = XtSafeBuffer.Get(stream);
            int bytes = GetBufferSize(Channels.inputs, buffer.frames);
            safe.Lock(in buffer);
            output.Write((byte[])safe.GetInput(), 0, bytes);
            safe.Unlock(in buffer);
            return 0;
        }

        // Normally don&#39;t do I/O in the callback.
        static int OnInterleavedNativeBuffer(XtStream stream, in XtBuffer buffer, object user)
        {
            var ctx = (Context)user;
            int bytes = GetBufferSize(Channels.inputs, buffer.frames);
            Marshal.Copy(buffer.input, ctx.intermediate, 0, bytes);
            ctx.recording.Write(ctx.intermediate, 0, bytes);
            return 0;
        }

        // Normally don&#39;t do I/O in the callback.
        static int OnNonInterleavedSafeBuffer(XtStream stream, in XtBuffer buffer, object user)
        {
            var output = (FileStream)user;
            XtSafeBuffer safe = XtSafeBuffer.Get(stream);
            int size = XtAudio.GetSampleAttributes(Mix.sample).size;
            safe.Lock(in buffer);
            for (int f = 0; f &lt; buffer.frames; f++)
                for (int c = 0; c &lt; Channels.inputs; c++)
                    output.Write(((byte[][])safe.GetInput())[c], f * size, size);
            safe.Unlock(in buffer);
            return 0;
        }

        // Normally don&#39;t do I/O in the callback.
        static unsafe int OnNonInterleavedNativeBuffer(XtStream stream, in XtBuffer buffer, object user)
        {
            var ctx = (Context)user;
            int size = XtAudio.GetSampleAttributes(Mix.sample).size;
            for (int f = 0; f &lt; buffer.frames; f++)
                for (int c = 0; c &lt; Channels.inputs; c++)
                {
                    IntPtr source = new IntPtr(&amp;(((byte**)buffer.input)[c][f * size]));
                    Marshal.Copy(source, ctx.intermediate, 0, size);
                    ctx.recording.Write(ctx.intermediate, 0, size);
                }
            return 0;
        }

        [STAThread]
        public static void Main()
        {
            XtStreamParams streamParams;
            XtDeviceStreamParams deviceParams;

            using XtPlatform platform = XtAudio.Init(null, IntPtr.Zero);
            XtSystem system = platform.SetupToSystem(XtSetup.ConsumerAudio);
            XtService service = platform.GetService(system);
            if (service == null) return;

            string defaultInput = service.GetDefaultDeviceId(false);
            if (defaultInput == null) return;
            using XtDevice device = service.OpenDevice(defaultInput);
            if (!device.SupportsFormat(Format)) return;
            XtBufferSize size = device.GetBufferSize(Format);

            Console.WriteLine(&quot;Capture interleaved, safe buffers...&quot;);
            streamParams = new XtStreamParams(true, OnInterleavedSafeBuffer, OnXRun, OnRunning);
            deviceParams = new XtDeviceStreamParams(in streamParams, in Format, size.current);
            using (FileStream recording = new FileStream(&quot;xt-audio-interleaved-safe.raw&quot;, FileMode.Create, FileAccess.Write))
            using (XtStream stream = device.OpenStream(in deviceParams, recording))
            using (XtSafeBuffer safe = XtSafeBuffer.Register(stream))
                RunStream(stream);

            Console.WriteLine(&quot;Capture interleaved, native buffers...&quot;);
            var context = new Context();
            streamParams = new XtStreamParams(true, OnInterleavedNativeBuffer, OnXRun, OnRunning);
            deviceParams = new XtDeviceStreamParams(in streamParams, in Format, size.current);
            using (FileStream recording = new FileStream(&quot;xt-audio-interleaved-native.raw&quot;, FileMode.Create, FileAccess.Write))
            using (XtStream stream = device.OpenStream(in deviceParams, context))
            {
                context.recording = recording;
                context.intermediate = new byte[GetBufferSize(Channels.inputs, stream.GetFrames())];
                RunStream(stream);
            }

            Console.WriteLine(&quot;Capture non-interleaved, safe buffers...&quot;);
            streamParams = new XtStreamParams(false, OnNonInterleavedSafeBuffer, OnXRun, OnRunning);
            deviceParams = new XtDeviceStreamParams(in streamParams, in Format, size.current);
            using (FileStream recording = new FileStream(&quot;xt-audio-non-interleaved-safe.raw&quot;, FileMode.Create, FileAccess.Write))
            using (XtStream stream = device.OpenStream(in deviceParams, recording))
            using (XtSafeBuffer safe = XtSafeBuffer.Register(stream))
                RunStream(stream);

            Console.WriteLine(&quot;Capture non-interleaved, native buffers...&quot;);
            context = new Context();
            streamParams = new XtStreamParams(false, OnNonInterleavedNativeBuffer, OnXRun, OnRunning);
            deviceParams = new XtDeviceStreamParams(in streamParams, in Format, size.current);
            using (FileStream recording = new FileStream(&quot;xt-audio-non-interleaved-native.raw&quot;, FileMode.Create, FileAccess.Write))
            using (XtStream stream = device.OpenStream(in deviceParams, context))
            {
                context.recording = recording;
                context.intermediate = new byte[GetBufferSize(Channels.inputs, stream.GetFrames())];
                RunStream(stream);
            }
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="advanced-record-cpp">
              <pre><code class="lang-cpp">#include &lt;xt/XtAudio.hpp&gt;

#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;

static Xt::Channels const Channels(2, 0, 0, 0);
static Xt::Mix const Mix(44100, Xt::Sample::Int24);
static Xt::Format const Format(Mix, Channels);

// Normally don&#39;t do I/O in the callback.
static void 
OnXRun(Xt::Stream const&amp; stream, int32_t index, void* user) 
{ std::cout &lt;&lt; &quot;XRun on device &quot; &lt;&lt; index &lt;&lt; &quot;.\n&quot;; }

static void
OnRunning(Xt::Stream const&amp; stream, bool running, uint64_t error, void* user)
{ 
  char const* evt = running? &quot;Started&quot;: &quot;Stopped&quot;;
  std::cout &lt;&lt; &quot;Stream event: &quot; &lt;&lt; evt &lt;&lt; &quot;, new state: &quot; &lt;&lt; stream.IsRunning() &lt;&lt; &quot;.\n&quot;; 
  if(error != 0) std::cout &lt;&lt; Xt::Audio::GetErrorInfo(error) &lt;&lt; &quot;.\n&quot;;
}

static void 
RunStream(Xt::Stream* stream)
{
  stream-&gt;Start();
  std::this_thread::sleep_for(std::chrono::seconds(2));
  stream-&gt;Stop();
}

static int32_t 
GetBufferSize(int32_t channels, int32_t frames)
{
  int32_t size = Xt::Audio::GetSampleAttributes(Mix.sample).size;
  return channels * frames * size;
}

// Normally don&#39;t do I/O in the callback.
static uint32_t 
OnInterleavedBuffer(Xt::Stream const&amp; stream, Xt::Buffer const&amp; buffer, void* user) 
{
  auto output = static_cast&lt;std::ofstream*&gt;(user);
  auto input = static_cast&lt;char const*&gt;(buffer.input);
  int32_t bytes = GetBufferSize(Channels.inputs, buffer.frames);
  output-&gt;write(input, bytes);
  return 0;
}

// Normally don&#39;t do I/O in the callback.
static uint32_t 
OnNonInterleavedBuffer(Xt::Stream const&amp; stream, Xt::Buffer const&amp; buffer, void* user) 
{
  auto output = static_cast&lt;std::ofstream*&gt;(user);  
  auto input = static_cast&lt;char const* const*&gt;(buffer.input);
  int32_t size = Xt::Audio::GetSampleAttributes(Mix.sample).size;
  for(int32_t f = 0; f &lt; buffer.frames; f++)
    for(int32_t c = 0; c &lt; Channels.inputs; c++)
      output-&gt;write(&amp;input[c][f * size], size);
  return 0;
}

int 
CaptureAdvancedMain() 
{
  std::unique_ptr&lt;Xt::Platform&gt; platform = Xt::Audio::Init(&quot;&quot;, nullptr);
  Xt::System system = platform-&gt;SetupToSystem(Xt::Setup::ConsumerAudio);
  std::unique_ptr&lt;Xt::Service&gt; service = platform-&gt;GetService(system);
  if(!service) return 0; 

  std::optional&lt;std::string&gt; id = service-&gt;GetDefaultDeviceId(false);
  if(!id.has_value()) return 0;
  std::unique_ptr&lt;Xt::Device&gt; device = service-&gt;OpenDevice(id.value());
  if(!device-&gt;SupportsFormat(Format)) return 0;
  Xt::BufferSize size = device-&gt;GetBufferSize(Format);

  std::cout &lt;&lt; &quot;Capture interleaved...\n&quot;;
  Xt::StreamParams streamParams(true, OnInterleavedBuffer, OnXRun, OnRunning);
  Xt::DeviceStreamParams deviceParams(streamParams, Format, size.current);
  {
    std::ofstream interleaved(&quot;xt-audio-interleaved.raw&quot;, std::ios::out | std::ios::binary);
    std::unique_ptr&lt;Xt::Stream&gt; stream = device-&gt;OpenStream(deviceParams, &amp;interleaved);
    RunStream(stream.get());
  }

  std::cout &lt;&lt; &quot;Capture non-interleaved...\n&quot;;
  streamParams = Xt::StreamParams(false, OnNonInterleavedBuffer, OnXRun, OnRunning);
  deviceParams = Xt::DeviceStreamParams(streamParams, Format, size.current);
  {
    std::ofstream nonInterleaved(&quot;xt-audio-non-interleaved.raw&quot;, std::ios::out | std::ios::binary);
    std::unique_ptr&lt;Xt::Stream&gt; stream = device-&gt;OpenStream(deviceParams, &amp;nonInterleaved);
    RunStream(stream.get());
  }

  return 0;
}</code></pre>
            </div>
          </div>
        </div>
        <div class="tab-pane" id="full-duplex">
          <ul class="nav nav-tabs">
            <li><a href="#full-duplex-java" data-toggle="tab">Java</a></li>
            <li><a href="#full-duplex-net" data-toggle="tab">.NET</a></li>
            <li><a href="#full-duplex-cpp" data-toggle="tab">C++</a></li>
          </ul>
          <div class="usage">
            <br/>
            &bull; Use JACK or ASIO for full-duplex operation.
          </div>
          <div class="tab-content">
            <div class="tab-pane" id="full-duplex-java">
              <pre><code class="lang-java">package xt.sample;

import xt.audio.Enums.XtSample;
import xt.audio.Enums.XtServiceCaps;
import xt.audio.Enums.XtSetup;
import xt.audio.Enums.XtSystem;
import xt.audio.Structs.XtBuffer;
import xt.audio.Structs.XtBufferSize;
import xt.audio.Structs.XtChannels;
import xt.audio.Structs.XtDeviceStreamParams;
import xt.audio.Structs.XtFormat;
import xt.audio.Structs.XtMix;
import xt.audio.Structs.XtStreamParams;
import xt.audio.XtAudio;
import xt.audio.XtDevice;
import xt.audio.XtPlatform;
import xt.audio.XtSafeBuffer;
import xt.audio.XtService;
import xt.audio.XtStream;

public class FullDuplex {

    // Normally don&#39;t do I/O in the callback.
    static void onXRun(XtStream stream, int index, Object user) {
        System.out.println(&quot;XRun on device &quot; + index + &quot;.&quot;);
    }

    static void onRunning(XtStream stream, boolean running, long error, Object user) {
        String evt = running? &quot;Started&quot;: &quot;Stopped&quot;;
        System.out.println(&quot;Stream event: &quot; + evt + &quot;, new state: &quot; + stream.isRunning() + &quot;.&quot;);
        if(error != 0) System.out.println(XtAudio.getErrorInfo(error).toString());
    }

    static int onBuffer(XtStream stream, XtBuffer buffer, Object user) throws Exception {
        XtSafeBuffer safe = XtSafeBuffer.get(stream);
        safe.lock(buffer);
        System.arraycopy(safe.getInput(), 0, safe.getOutput(), 0, buffer.frames * 2);
        safe.unlock(buffer);
        return 0;
    }

    public static void main() throws Exception {
        XtFormat format;
        XtStreamParams streamParams;
        XtDeviceStreamParams deviceParams;
        XtFormat int44100 = new XtFormat(new XtMix(44100, XtSample.INT32), new XtChannels(2, 0, 2, 0));
        XtFormat int48000 = new XtFormat(new XtMix(48000, XtSample.INT32), new XtChannels(2, 0, 2, 0));
        XtFormat float44100 = new XtFormat(new XtMix(44100, XtSample.FLOAT32), new XtChannels(2, 0, 2, 0));
        XtFormat float48000 = new XtFormat(new XtMix(48000, XtSample.FLOAT32), new XtChannels(2, 0, 2, 0));

        try(XtPlatform platform = XtAudio.init(null, null)) {
            XtSystem system = platform.setupToSystem(XtSetup.PRO_AUDIO);
            XtService service = platform.getService(system);
            if(service == null || !service.getCapabilities().contains(XtServiceCaps.FULL_DUPLEX)) return;

            String defaultOutput = service.getDefaultDeviceId(true);
            if(defaultOutput == null) return;
            try(XtDevice device = service.openDevice(defaultOutput)) {
                if(device.supportsFormat(int44100)) format = int44100;
                else if(device.supportsFormat(int48000)) format = int48000;
                else if(device.supportsFormat(float44100)) format = float44100;
                else if(device.supportsFormat(float48000)) format = float48000;
                else return;

                XtBufferSize size = device.getBufferSize(format);
                streamParams = new XtStreamParams(true, FullDuplex::onBuffer, FullDuplex::onXRun, FullDuplex::onRunning);
                deviceParams = new XtDeviceStreamParams(streamParams, format, size.current);
                try(XtStream stream = device.openStream(deviceParams, null);
                    XtSafeBuffer safe = XtSafeBuffer.register(stream)) {
                    stream.start();
                    Thread.sleep(2000);
                    stream.stop();
                }
            }
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="full-duplex-net">
              <pre><code class="lang-cs">using System;
using System.Threading;

namespace Xt
{
    public class FullDuplex
    {
        // Normally don&#39;t do I/O in the callback.
        static void OnXRun(XtStream stream, int index, object user)
        =&gt; Console.WriteLine(&quot;XRun on device &quot; + index + &quot;.&quot;);

        static void OnRunning(XtStream stream, bool running, ulong error, object user)
        {
            string evt = running ? &quot;Started&quot; : &quot;Stopped&quot;;
            Console.WriteLine(&quot;Stream event: &quot; + evt + &quot;, new state: &quot; + stream.IsRunning() + &quot;.&quot;);
            if (error != 0) Console.WriteLine(XtAudio.GetErrorInfo(error).ToString());
        }

        static int OnBuffer(XtStream stream, in XtBuffer buffer, object user)
        {
            XtSafeBuffer safe = XtSafeBuffer.Get(stream);
            safe.Lock(in buffer);
            Buffer.BlockCopy(safe.GetInput(), 0, safe.GetOutput(), 0, buffer.frames * 2 * 4);
            safe.Unlock(in buffer);
            return 0;
        }

        [STAThread]
        public static void Main()
        {
            XtFormat format;
            XtStreamParams streamParams;
            XtDeviceStreamParams deviceParams;
            XtFormat int44100 = new XtFormat(new XtMix(44100, XtSample.Int32), new XtChannels(2, 0, 2, 0));
            XtFormat int48000 = new XtFormat(new XtMix(48000, XtSample.Int32), new XtChannels(2, 0, 2, 0));
            XtFormat float44100 = new XtFormat(new XtMix(44100, XtSample.Float32), new XtChannels(2, 0, 2, 0));
            XtFormat float48000 = new XtFormat(new XtMix(48000, XtSample.Float32), new XtChannels(2, 0, 2, 0));

            using XtPlatform platform = XtAudio.Init(null, IntPtr.Zero);
            XtSystem system = platform.SetupToSystem(XtSetup.ProAudio);
            XtService service = platform.GetService(system);
            if (service == null || (service.GetCapabilities() &amp; XtServiceCaps.FullDuplex) == 0) return;

            string defaultId = service.GetDefaultDeviceId(true);
            if (defaultId == null) return;
            using XtDevice device = service.OpenDevice(defaultId);
            if (device.SupportsFormat(int44100)) format = int44100;
            else if (device.SupportsFormat(int48000)) format = int48000;
            else if (device.SupportsFormat(float44100)) format = float44100;
            else if (device.SupportsFormat(float48000)) format = float48000;
            else return;

            XtBufferSize size = device.GetBufferSize(format);
            streamParams = new XtStreamParams(true, OnBuffer, OnXRun, OnRunning);
            deviceParams = new XtDeviceStreamParams(in streamParams, in format, size.current);
            using XtStream stream = device.OpenStream(in deviceParams, null);
            using XtSafeBuffer safe = XtSafeBuffer.Register(stream);
            stream.Start();
            Thread.Sleep(2000);
            stream.Stop();
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="full-duplex-cpp">
              <pre><code class="lang-cpp">#include &lt;xt/XtAudio.hpp&gt;

#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

// Normally don&#39;t do I/O in the callback.
static void 
OnXRun(Xt::Stream const&amp; stream, int32_t index, void* user) 
{ std::cout &lt;&lt; &quot;XRun on device &quot; &lt;&lt; index &lt;&lt; &quot;.\n&quot;; }

static uint32_t 
OnBuffer(Xt::Stream const&amp; stream, Xt::Buffer const&amp; buffer, void* user) 
{
  int32_t bytes = buffer.frames * 2 * 4;
  std::memcpy(buffer.output, buffer.input, bytes);
  return 0;
}

static void
OnRunning(Xt::Stream const&amp; stream, bool running, uint64_t error, void* user)
{ 
  char const* evt = running? &quot;Started&quot;: &quot;Stopped&quot;;
  std::cout &lt;&lt; &quot;Stream event: &quot; &lt;&lt; evt &lt;&lt; &quot;, new state: &quot; &lt;&lt; stream.IsRunning() &lt;&lt; &quot;.\n&quot;; 
  if(error != 0) std::cout &lt;&lt; Xt::Audio::GetErrorInfo(error) &lt;&lt; &quot;.\n&quot;;
}

int 
FullDuplexMain() 
{
  Xt::Format format;
  Xt::Format int44100(Xt::Mix(44100, Xt::Sample::Int32), Xt::Channels(2, 0, 2, 0));
  Xt::Format int48000(Xt::Mix(48000, Xt::Sample::Int32), Xt::Channels(2, 0, 2, 0));
  Xt::Format float44100(Xt::Mix(44100, Xt::Sample::Float32), Xt::Channels(2, 0, 2, 0));
  Xt::Format float48000(Xt::Mix(48000, Xt::Sample::Float32), Xt::Channels(2, 0, 2, 0));

  std::unique_ptr&lt;Xt::Platform&gt; platform = Xt::Audio::Init(&quot;&quot;, nullptr);
  Xt::System system = platform-&gt;SetupToSystem(Xt::Setup::ProAudio);
  std::unique_ptr&lt;Xt::Service&gt; service = platform-&gt;GetService(system);
  if(!service || (service-&gt;GetCapabilities() &amp; Xt::ServiceCapsFullDuplex) == 0) return 0;

  std::optional&lt;std::string&gt; id = service-&gt;GetDefaultDeviceId(true);
  if(!id.has_value()) return 0;
  std::unique_ptr&lt;Xt::Device&gt; device = service-&gt;OpenDevice(id.value());

  if(device-&gt;SupportsFormat(int44100)) format = int44100;
  else if(device-&gt;SupportsFormat(int48000)) format = int48000;
  else if(device-&gt;SupportsFormat(float44100)) format = float44100;
  else if(device-&gt;SupportsFormat(float48000)) format = float48000;
  else return 0;

  double bufferSize = device-&gt;GetBufferSize(format).current;
  Xt::StreamParams streamParams(true, OnBuffer, OnXRun, OnRunning);
  Xt::DeviceStreamParams deviceParams(streamParams, format, bufferSize);
  std::unique_ptr&lt;Xt::Stream&gt; stream = device-&gt;OpenStream(deviceParams, nullptr);
  stream-&gt;Start();
  std::this_thread::sleep_for(std::chrono::seconds(2));
  stream-&gt;Stop();

  return 0;
}</code></pre>
            </div>
          </div>
        </div>
        <div class="tab-pane" id="aggregate">
          <ul class="nav nav-tabs">
            <li><a href="#aggregate-java" data-toggle="tab">Java</a></li>
            <li><a href="#aggregate-net" data-toggle="tab">.NET</a></li>
            <li><a href="#aggregate-cpp" data-toggle="tab">C++</a></li>
          </ul>
          <div class="usage">
            <br/>
            &bull; Combine any number of input and output devices into a single stream.
          </div>
          <div class="tab-content">
            <div class="tab-pane" id="aggregate-java">
              <pre><code class="lang-java">package xt.sample;

import xt.audio.Enums.XtSample;
import xt.audio.Enums.XtServiceCaps;
import xt.audio.Enums.XtSetup;
import xt.audio.Enums.XtSystem;
import xt.audio.Structs.XtAggregateDeviceParams;
import xt.audio.Structs.XtAggregateStreamParams;
import xt.audio.Structs.XtBuffer;
import xt.audio.Structs.XtChannels;
import xt.audio.Structs.XtFormat;
import xt.audio.Structs.XtMix;
import xt.audio.Structs.XtStreamParams;
import xt.audio.XtAudio;
import xt.audio.XtDevice;
import xt.audio.XtPlatform;
import xt.audio.XtSafeBuffer;
import xt.audio.XtService;
import xt.audio.XtStream;

public class Aggregate {

    // Normally don&#39;t do I/O in the callback.
    static void onXRun(XtStream stream, int index, Object user) {
        System.out.println(&quot;XRun on device &quot; + index + &quot;.&quot;);
    }

    static void onRunning(XtStream stream, boolean running, long error, Object user) {
        String evt = running? &quot;Started&quot;: &quot;Stopped&quot;;
        System.out.println(&quot;Stream event: &quot; + evt + &quot;, new state: &quot; + stream.isRunning() + &quot;.&quot;);
        if(error != 0) System.out.println(XtAudio.getErrorInfo(error).toString());
    }

    static int onBuffer(XtStream stream, XtBuffer buffer, Object user) throws Exception {
        XtSafeBuffer safe = XtSafeBuffer.get(stream);
        safe.lock(buffer);
        int count = buffer.frames * stream.getFormat().channels.inputs;
        System.arraycopy(safe.getInput(), 0, safe.getOutput(), 0, count);
        safe.unlock(buffer);
        return 0;
    }

    public static void main() throws Exception {

        XtAggregateStreamParams aggregateParams;
        XtMix mix = new XtMix(48000, XtSample.INT16);
        XtFormat inputFormat = new XtFormat(mix, new XtChannels(2, 0, 0, 0));
        XtFormat outputFormat = new XtFormat(mix, new XtChannels(0, 0, 2, 0));

        try(XtPlatform platform = XtAudio.init(null, null)) {
            XtSystem system = platform.setupToSystem(XtSetup.SYSTEM_AUDIO);
            XtService service = platform.getService(system);
            if(service == null || !service.getCapabilities().contains(XtServiceCaps.AGGREGATION)) return;

            String defaultInput = service.getDefaultDeviceId(false);
            String defaultOutput = service.getDefaultDeviceId(true);
            if(defaultInput == null || defaultOutput == null) return;

            try(XtDevice input = service.openDevice(defaultInput);
                XtDevice output = service.openDevice(defaultOutput)) {
                if(!input.supportsFormat(inputFormat)) return;
                if(!output.supportsFormat(outputFormat)) return;

                XtAggregateDeviceParams[] deviceParams = new XtAggregateDeviceParams[2];
                deviceParams[0] = new XtAggregateDeviceParams(input, inputFormat.channels, 30.0);
                deviceParams[1] = new XtAggregateDeviceParams(output, outputFormat.channels, 30.0);
                XtStreamParams streamParams = new XtStreamParams(true, Aggregate::onBuffer, Aggregate::onXRun, Aggregate::onRunning);
                aggregateParams = new XtAggregateStreamParams(streamParams, deviceParams, 2, mix, output);
                try(XtStream stream = service.aggregateStream(aggregateParams, null);
                    XtSafeBuffer safe = XtSafeBuffer.register(stream)) {
                    stream.start();
                    Thread.sleep(2000);
                    stream.stop();
                }
            }
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="aggregate-net">
              <pre><code class="lang-cs">using System;
using System.Threading;

namespace Xt
{
    public class Aggregate
    {
        // Normally don&#39;t do I/O in the callback.
        static void OnXRun(XtStream stream, int index, object user)
        =&gt; Console.WriteLine(&quot;XRun on device &quot; + index + &quot;.&quot;);

        static void OnRunning(XtStream stream, bool running, ulong error, object user)
        {
            string evt = running ? &quot;Started&quot; : &quot;Stopped&quot;;
            Console.WriteLine(&quot;Stream event: &quot; + evt + &quot;, new state: &quot; + stream.IsRunning() + &quot;.&quot;);
            if (error != 0) Console.WriteLine(XtAudio.GetErrorInfo(error).ToString());
        }

        static int OnBuffer(XtStream stream, in XtBuffer buffer, object user)
        {
            XtSafeBuffer safe = XtSafeBuffer.Get(stream);
            safe.Lock(buffer);
            XtFormat format = stream.GetFormat();
            XtAttributes attrs = XtAudio.GetSampleAttributes(format.mix.sample);
            int bytes = buffer.frames * stream.GetFormat().channels.inputs * attrs.size;
            Buffer.BlockCopy(safe.GetInput(), 0, safe.GetOutput(), 0, bytes);
            safe.Unlock(buffer);
            return 0;
        }

        [STAThread]
        public static void Main()
        {
            XtAggregateStreamParams aggregateParams;
            XtMix mix = new XtMix(48000, XtSample.Int16);
            XtFormat inputFormat = new XtFormat(mix, new XtChannels(2, 0, 0, 0));
            XtFormat outputFormat = new XtFormat(mix, new XtChannels(0, 0, 2, 0));

            using XtPlatform platform = XtAudio.Init(null, IntPtr.Zero);
            XtSystem system = platform.SetupToSystem(XtSetup.SystemAudio);
            XtService service = platform.GetService(system);
            if (service == null || (service.GetCapabilities() &amp; XtServiceCaps.Aggregation) == 0) return;

            string defaultInput = service.GetDefaultDeviceId(false);
            if (defaultInput == null) return;
            using XtDevice input = service.OpenDevice(defaultInput);
            if (!input.SupportsFormat(inputFormat)) return;

            string defaultOutput = service.GetDefaultDeviceId(true);
            if (defaultOutput == null) return;
            using XtDevice output = service.OpenDevice(defaultOutput);
            if (!output.SupportsFormat(outputFormat)) return;

            XtAggregateDeviceParams[] deviceParams = new XtAggregateDeviceParams[2];
            deviceParams[0] = new XtAggregateDeviceParams(input, in inputFormat.channels, 30.0);
            deviceParams[1] = new XtAggregateDeviceParams(output, in outputFormat.channels, 30.0);
            XtStreamParams streamParams = new XtStreamParams(true, OnBuffer, OnXRun, OnRunning);
            aggregateParams = new XtAggregateStreamParams(in streamParams, deviceParams, 2, mix, output);
            using XtStream stream = service.AggregateStream(in aggregateParams, null);
            using XtSafeBuffer safe = XtSafeBuffer.Register(stream);
            stream.Start();
            Thread.Sleep(2000);
            stream.Stop();
        }
    }
}</code></pre>
            </div>
            <div class="tab-pane" id="aggregate-cpp">
              <pre><code class="lang-cpp">#include &lt;xt/XtAudio.hpp&gt;

#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;cstdint&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

// Normally don&#39;t do I/O in the callback.
static void 
OnXRun(Xt::Stream const&amp; stream, int32_t index, void* user) 
{ std::cout &lt;&lt; &quot;XRun on device &quot; &lt;&lt; index &lt;&lt; &quot;.\n&quot;; }

static void
OnRunning(Xt::Stream const&amp; stream, bool running, uint64_t error, void* user)
{ 
  char const* evt = running? &quot;Started&quot;: &quot;Stopped&quot;;
  std::cout &lt;&lt; &quot;Stream event: &quot; &lt;&lt; evt &lt;&lt; &quot;, new state: &quot; &lt;&lt; stream.IsRunning() &lt;&lt; &quot;.\n&quot;; 
  if(error != 0) std::cout &lt;&lt; Xt::Audio::GetErrorInfo(error) &lt;&lt; &quot;.\n&quot;;
}

static uint32_t 
OnBuffer(Xt::Stream const&amp; stream, Xt::Buffer const&amp; buffer, void* user) 
{
  Xt::Format const&amp; format = stream.GetFormat();
  Xt::Attributes attrs = Xt::Audio::GetSampleAttributes(format.mix.sample);
  int32_t bytes = buffer.frames * format.channels.inputs * attrs.size;
  std::memcpy(buffer.output, buffer.input, bytes);
  return 0;
}

int 
AggregateMain()
{
  Xt::Mix mix(48000, Xt::Sample::Int16);
  Xt::Format inputFormat(mix, Xt::Channels(2, 0, 0, 0));
  Xt::Format outputFormat(mix, Xt::Channels(0, 0, 2, 0));
  
  std::unique_ptr&lt;Xt::Platform&gt; platform = Xt::Audio::Init(&quot;&quot;, nullptr);
  Xt::System system = platform-&gt;SetupToSystem(Xt::Setup::SystemAudio);
  std::unique_ptr&lt;Xt::Service&gt; service = platform-&gt;GetService(system);
  if(!service || (service-&gt;GetCapabilities() &amp; Xt::ServiceCapsAggregation) == 0) return 0;

  std::optional&lt;std::string&gt; defaultInput = service-&gt;GetDefaultDeviceId(false);
  if(!defaultInput.has_value()) return 0;
  std::unique_ptr&lt;Xt::Device&gt; input = service-&gt;OpenDevice(defaultInput.value());
  if(!input-&gt;SupportsFormat(inputFormat)) return 0;

  std::optional&lt;std::string&gt; defaultOutput = service-&gt;GetDefaultDeviceId(true);
  if(!defaultOutput.has_value()) return 0;
  std::unique_ptr&lt;Xt::Device&gt; output = service-&gt;OpenDevice(defaultOutput.value());
  if(!output-&gt;SupportsFormat(outputFormat)) return 0;

  Xt::AggregateDeviceParams deviceParams[2];
  deviceParams[0] = Xt::AggregateDeviceParams(input.get(), inputFormat.channels, 30.0);
  deviceParams[1] = Xt::AggregateDeviceParams(output.get(), outputFormat.channels, 30.0);
  Xt::StreamParams streamParams(true, OnBuffer, OnXRun, OnRunning);
  Xt::AggregateStreamParams aggregateParams(streamParams, deviceParams, 2, mix, output.get());
  std::unique_ptr&lt;Xt::Stream&gt; stream = service-&gt;AggregateStream(aggregateParams, nullptr);
  stream-&gt;Start();
  std::this_thread::sleep_for(std::chrono::seconds(2));
  stream-&gt;Stop();
  return 0;
}</code></pre>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/highlight.pack.js"></script>
    <script>$('#tabs').tab();hljs.initHighlightingOnLoad();</script>
  </body>
</html>