<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>XT-Audio: XT-Audio</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XT-Audio
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">XT-Audio </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="abstractions"></a>
Core abstractions</h1>
<p><b>Systems and services</b></p>
<p>An audio service is an implementation of the XtService API on a specific backend. Supported backends include DirectSound, WASAPI and ASIO on windows, and PulseAudio, ALSA and JACK on linux. Services are used primarily to query and open available audio devices.</p>
<p><b>Devices</b></p>
<p>An audio device is an implementation of the XtDevice API on a specific backend. Depending on the backend type, devices may directly correspond to physical audio cards (ASIO, ALSA hw, WASAPI exclusive), system mixers on top of such cards (ALSA plughw, WASAPI shared, DirectSound), or sound services which allow user- defined routing from application input/output to physical or virtual devices (JACK and PulseAudio). The device API may be used to query format support and buffer sizes, and to create audio streams.</p>
<p><b>Streams</b></p>
<p>An audio stream is an implementation of the XtStream API on a specific backend. Each stream is tied to an application-defined callback function (XtStreamCallback) which is called whenever the stream is ready to deliver or receive more data. The XtStream API can be used to control (start/stop) audio streams and to query latencies and buffer sizes.</p>
<h1><a class="anchor" id="usage"></a>
Basic usage</h1>
<p>An application must first initialize the library using XtAudioInit. From there, it can select an audio service, query for available devices, and open streams on those devices. The choice of backend (system) greatly affects the way audio is streamed in terms of latency, supported formats and whether the application takes system-wide exclusive control of a device. If you know exactly what your application needs, use XtAudioGetServiceBySetup or XtAudioGetServiceBySystem to select a backend with specific characteristics. Otherwise it's probably best to let the end-user pick the system and device to use.</p>
<p>Streaming audio with XT-Audio involves at least these steps:</p><ol type="1">
<li>Initialize (XtAudioInit)</li>
<li>Select service (XtAudioGetServiceByIndex/XtAudioGetServiceBySetup/XtAudioGetServiceBySystem)</li>
<li>Select device (XtServiceOpenDevice/XtServiceOpenDefaultDevice)</li>
<li>Test format and buffer size support (XtDeviceSupportsFormat/XtDeviceGetBuffer)</li>
<li>Open a stream (XtDeviceOpenStream/XtServiceAggregateStream)</li>
<li>Start running (XtStreamStart)</li>
<li>Stop running (XtStreamStop)</li>
<li>Cleanup stream (XtStreamDestroy)</li>
<li>Cleanup device (XtDeviceDestroy)</li>
<li>Cleanup library (XtAudioTerminate)</li>
</ol>
<h1><a class="anchor" id="langdiffs"></a>
API differences between languages</h1>
<p><b>Error handling</b></p>
<p>The core API uses error codes exclusively. C++, Java and C# API's use only exceptions.</p>
<p><b>String handling</b></p>
<p>In the C and C++ API's, all strings are encoded as UTF-8. In the C# and Java API's strings use the built-in string type.</p>
<p><b>Resource handling</b></p>
<p>In all language API's there are 3 resources that must be explicitly managed: devices, streams, and the library itself. For C, this means XtDeviceDestroy/XtStreamDestroy/XtAudioTerminate. For C++ everything is handled using RAII, the XtAudio constructor calls XtAudioInit and destructor calls XtAudioTerminate. Devices and streams are handled using std::unique_ptrs. For Java each resource implements Closeable, for C# IDisposable. Except for the C API these are the only resources the application needs to be concerned about. For C, it is documented whether return values and output parameters should be explicitly cleaned up using <a class="el" href="group__audio.html#ga5db3bd8679e143d799494cdb1e77a11f" title="Standard free() wrapper. ">XtAudioFree()</a>.</p>
<p><b>Audio buffers</b></p>
<p>When using interleaved access, the data passed to the callback is a pointer to a single array of samples, and the audio buffer contains alternating samples for each channel, e.g. [LRLRLR] for a stereo stream. When using non-interleaved access, there is one audio buffer for each channel, and the data passed to the callback is a pointer to an array of pointers each pointing to the audio buffer for a single channel, e.g. [LLL][RRR] for a stereo stream.</p>
<p>The input/output buffers passed to XtStreamCallback should be cast to the appropriate type before usage. For C and C++ (and Java and C# in raw mode) this means unsigned char*, short*, int* or float* for interleaved buffers, or unsigned char**, short**, int** or float** for non-interleaved buffers. For Java and C# this means byte[], short[], int[] or float[] for interleaved buffers or byte[][], short[][], int[][] or float[][] for non-interleaved buffers. Applications should never write to the input buffer.</p>
<p><b>Stream aggregation</b></p>
<p>XT-Audio allows an application to open an audio stream on more than one device. This is primarily intended to emulate full-duplex operation on systems which don't natively support it, but may be used to aggregate any number of input, output and/or full-duplex streams. The resulting stream's channel count will be equal to the total number of channels requested for each of the underlying streams. Aggregate streams introduce an intermediate buffer to keep underlying streams in sync, and as such (and unlike anything else in XT-Audio) they actually add latency to a running stream. Aggregate streams are created using XtServiceAggregateStream instead of XtDeviceOpenStream. Other than that, the stream interface (including callback functions) is exactly the same as for regular audio streams. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
